/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/sketch-js/js/sketch.js":
/*!*********************************************!*\
  !*** ./node_modules/sketch-js/js/sketch.js ***!
  \*********************************************/
/***/ (function(module) {

eval("\n/* Copyright (C) 2013 Justin Windle, http://soulwire.co.uk */\n\n(function ( root, factory ) {\n\n  if ( true ) {\n\n    // CommonJS like\n    module.exports = factory(root, root.document);\n\n  } else {}\n\n}( typeof window !== \"undefined\" ? window : this, function ( window, document ) {\n\n\n  \"use strict\";\n\n  /*\n  ----------------------------------------------------------------------\n\n    Config\n\n  ----------------------------------------------------------------------\n  */\n\n  var MATH_PROPS = 'E LN10 LN2 LOG2E LOG10E PI SQRT1_2 SQRT2 abs acos asin atan ceil cos exp floor log round sin sqrt tan atan2 pow max min'.split( ' ' );\n  var HAS_SKETCH = '__hasSketch';\n  var M = Math;\n\n  var CANVAS = 'canvas';\n  var WEBGL = 'webgl';\n  var DOM = 'dom';\n\n  var doc = document;\n  var win = window;\n\n  var instances = [];\n\n  var defaults = {\n\n    fullscreen: true,\n    autostart: true,\n    autoclear: true,\n    autopause: true,\n    container: doc.body,\n    interval: 1,\n    globals: true,\n    retina: false,\n    type: CANVAS\n  };\n\n  var keyMap = {\n\n     8: 'BACKSPACE',\n     9: 'TAB',\n    13: 'ENTER',\n    16: 'SHIFT',\n    27: 'ESCAPE',\n    32: 'SPACE',\n    37: 'LEFT',\n    38: 'UP',\n    39: 'RIGHT',\n    40: 'DOWN'\n  };\n\n  /*\n  ----------------------------------------------------------------------\n\n    Utilities\n\n  ----------------------------------------------------------------------\n  */\n\n  function isArray( object ) {\n\n    return Object.prototype.toString.call( object ) == '[object Array]';\n  }\n\n  function isFunction( object ) {\n\n    return typeof object == 'function';\n  }\n\n  function isNumber( object ) {\n\n    return typeof object == 'number';\n  }\n\n  function isString( object ) {\n\n    return typeof object == 'string';\n  }\n\n  function keyName( code ) {\n\n    return keyMap[ code ] || String.fromCharCode( code );\n  }\n\n  function extend( target, source, overwrite ) {\n\n    for ( var key in source )\n\n      if ( overwrite || !( key in target ) )\n\n        target[ key ] = source[ key ];\n\n    return target;\n  }\n\n  function proxy( method, context ) {\n\n    return function() {\n\n      method.apply( context, arguments );\n    };\n  }\n\n  function clone( target ) {\n\n    var object = {};\n\n    for ( var key in target ) {\n      \n      if ( key === 'webkitMovementX' || key === 'webkitMovementY' )\n        continue;\n\n      if ( isFunction( target[ key ] ) )\n\n        object[ key ] = proxy( target[ key ], target );\n\n      else\n\n        object[ key ] = target[ key ];\n    }\n\n    return object;\n  }\n\n  /*\n  ----------------------------------------------------------------------\n\n    Constructor\n\n  ----------------------------------------------------------------------\n  */\n\n  function constructor( context ) {\n\n    var request, handler, target, parent, bounds, index, suffix, clock, node, copy, type, key, val, min, max, w, h;\n\n    var counter = 0;\n    var touches = [];\n    var resized = false;\n    var setup = false;\n    var ratio = win.devicePixelRatio || 1;\n    var isDiv = context.type == DOM;\n    var is2D = context.type == CANVAS;\n\n    var mouse = {\n      x:  0.0, y:  0.0,\n      ox: 0.0, oy: 0.0,\n      dx: 0.0, dy: 0.0\n    };\n\n    var eventMap = [\n\n      context.eventTarget || context.element,\n\n        pointer, 'mousedown', 'touchstart',\n        pointer, 'mousemove', 'touchmove',\n        pointer, 'mouseup', 'touchend',\n        pointer, 'click',\n        pointer, 'mouseout',\n        pointer, 'mouseover',\n\n      doc,\n\n        keypress, 'keydown', 'keyup',\n\n      win,\n\n        active, 'focus', 'blur',\n        resize, 'resize'\n    ];\n\n    var keys = {}; for ( key in keyMap ) keys[ keyMap[ key ] ] = false;\n\n    function trigger( method ) {\n\n      if ( isFunction( method ) )\n\n        method.apply( context, [].splice.call( arguments, 1 ) );\n    }\n\n    function bind( on ) {\n\n      for ( index = 0; index < eventMap.length; index++ ) {\n\n        node = eventMap[ index ];\n\n        if ( isString( node ) )\n\n          target[ ( on ? 'add' : 'remove' ) + 'EventListener' ].call( target, node, handler, false );\n\n        else if ( isFunction( node ) )\n\n          handler = node;\n\n        else target = node;\n      }\n    }\n\n    function update() {\n\n      cAF( request );\n      request = rAF( update );\n\n      if ( !setup ) {\n\n        trigger( context.setup );\n        setup = isFunction( context.setup );\n      }\n\n      if ( !resized ) {\n        trigger( context.resize );\n        resized = isFunction( context.resize );\n      }\n\n      if ( context.running && !counter ) {\n\n        context.dt = ( clock = +new Date() ) - context.now;\n        context.millis += context.dt;\n        context.now = clock;\n\n        trigger( context.update );\n\n        // Pre draw\n\n        if ( is2D ) {\n\n          if ( context.retina ) {\n\n            context.save();\n            \n            if (context.autoclear) {\n              context.scale( ratio, ratio );\n            }\n          }\n\n          if ( context.autoclear )\n\n            context.clear();\n        }\n\n        // Draw\n\n        trigger( context.draw );\n\n        // Post draw\n\n        if ( is2D && context.retina )\n\n          context.restore();\n      }\n\n      counter = ++counter % context.interval;\n    }\n\n    function resize() {\n\n      target = isDiv ? context.style : context.canvas;\n      suffix = isDiv ? 'px' : '';\n\n      w = context.width;\n      h = context.height;\n\n      if ( context.fullscreen ) {\n\n        h = context.height = win.innerHeight;\n        w = context.width = win.innerWidth;\n      }\n\n      if ( context.retina && is2D && ratio ) {\n\n        target.style.height = h + 'px';\n        target.style.width = w + 'px';\n\n        w *= ratio;\n        h *= ratio;\n      }\n\n      if ( target.height !== h )\n\n        target.height = h + suffix;\n\n      if ( target.width !== w )\n\n        target.width = w + suffix;\n\n      if ( is2D && !context.autoclear && context.retina )\n\n        context.scale( ratio, ratio );\n\n      if ( setup ) trigger( context.resize );\n    }\n\n    function align( touch, target ) {\n\n      bounds = target.getBoundingClientRect();\n\n      touch.x = touch.pageX - bounds.left - (win.scrollX || win.pageXOffset);\n      touch.y = touch.pageY - bounds.top - (win.scrollY || win.pageYOffset);\n\n      return touch;\n    }\n\n    function augment( touch, target ) {\n\n      align( touch, context.element );\n\n      target = target || {};\n\n      target.ox = target.x || touch.x;\n      target.oy = target.y || touch.y;\n\n      target.x = touch.x;\n      target.y = touch.y;\n\n      target.dx = target.x - target.ox;\n      target.dy = target.y - target.oy;\n\n      return target;\n    }\n\n    function process( event ) {\n\n      event.preventDefault();\n\n      copy = clone( event );\n      copy.originalEvent = event;\n\n      if ( copy.touches ) {\n\n        touches.length = copy.touches.length;\n\n        for ( index = 0; index < copy.touches.length; index++ )\n\n          touches[ index ] = augment( copy.touches[ index ], touches[ index ] );\n\n      } else {\n\n        touches.length = 0;\n        touches[0] = augment( copy, mouse );\n      }\n\n      extend( mouse, touches[0], true );\n\n      return copy;\n    }\n\n    function pointer( event ) {\n\n      event = process( event );\n\n      min = ( max = eventMap.indexOf( type = event.type ) ) - 1;\n\n      context.dragging =\n\n        /down|start/.test( type ) ? true :\n\n        /up|end/.test( type ) ? false :\n\n        context.dragging;\n\n      while( min )\n\n        isString( eventMap[ min ] ) ?\n\n          trigger( context[ eventMap[ min-- ] ], event ) :\n\n        isString( eventMap[ max ] ) ?\n\n          trigger( context[ eventMap[ max++ ] ], event ) :\n\n        min = 0;\n    }\n\n    function keypress( event ) {\n\n      key = event.keyCode;\n      val = event.type == 'keyup';\n      keys[ key ] = keys[ keyName( key ) ] = !val;\n\n      trigger( context[ event.type ], event );\n    }\n\n    function active( event ) {\n\n      if ( context.autopause )\n\n        ( event.type == 'blur' ? stop : start )();\n\n      trigger( context[ event.type ], event );\n    }\n\n    // Public API\n\n    function start() {\n\n      context.now = +new Date();\n      context.running = true;\n    }\n\n    function stop() {\n\n      context.running = false;\n    }\n\n    function toggle() {\n\n      ( context.running ? stop : start )();\n    }\n\n    function clear() {\n\n      if ( is2D )\n\n        context.clearRect( 0, 0, context.width * ratio, context.height * ratio );\n    }\n\n    function destroy() {\n\n      parent = context.element.parentNode;\n      index = instances.indexOf( context );\n\n      if ( parent ) parent.removeChild( context.element );\n      if ( ~index ) instances.splice( index, 1 );\n\n      bind( false );\n      stop();\n    }\n\n    extend( context, {\n\n      touches: touches,\n      mouse: mouse,\n      keys: keys,\n\n      dragging: false,\n      running: false,\n      millis: 0,\n      now: NaN,\n      dt: NaN,\n\n      destroy: destroy,\n      toggle: toggle,\n      clear: clear,\n      start: start,\n      stop: stop\n    });\n\n    instances.push( context );\n\n    return ( context.autostart && start(), bind( true ), resize(), update(), context );\n  }\n\n  /*\n  ----------------------------------------------------------------------\n\n    Global API\n\n  ----------------------------------------------------------------------\n  */\n\n  var element, context, Sketch = {\n\n    CANVAS: CANVAS,\n    WEB_GL: WEBGL,\n    WEBGL: WEBGL,\n    DOM: DOM,\n\n    instances: instances,\n\n    install: function( context ) {\n\n      if ( !context[ HAS_SKETCH ] ) {\n\n        for ( var i = 0; i < MATH_PROPS.length; i++ )\n\n          context[ MATH_PROPS[i] ] = M[ MATH_PROPS[i] ];\n\n        extend( context, {\n\n          TWO_PI: M.PI * 2,\n          HALF_PI: M.PI / 2,\n          QUARTER_PI: M.PI / 4,\n\n          random: function( min, max ) {\n\n            if ( isArray( min ) )\n\n              return min[ ~~( M.random() * min.length ) ];\n\n            if ( !isNumber( max ) )\n\n              max = min || 1, min = 0;\n\n            return min + M.random() * ( max - min );\n          },\n\n          lerp: function( min, max, amount ) {\n\n            return min + amount * ( max - min );\n          },\n\n          map: function( num, minA, maxA, minB, maxB ) {\n\n            return ( num - minA ) / ( maxA - minA ) * ( maxB - minB ) + minB;\n          }\n        });\n\n        context[ HAS_SKETCH ] = true;\n      }\n    },\n\n    create: function( options ) {\n\n      options = extend( options || {}, defaults );\n\n      if ( options.globals ) Sketch.install( self );\n\n      element = options.element = options.element || doc.createElement( options.type === DOM ? 'div' : 'canvas' );\n\n      context = options.context = options.context || (function() {\n\n        switch( options.type ) {\n\n          case CANVAS:\n\n            return element.getContext( '2d', options );\n\n          case WEBGL:\n\n            return element.getContext( 'webgl', options ) || element.getContext( 'experimental-webgl', options );\n\n          case DOM:\n\n            return element.canvas = element;\n        }\n\n      })();\n\n      ( options.container || doc.body ).appendChild( element );\n\n      return Sketch.augment( context, options );\n    },\n\n    augment: function( context, options ) {\n\n      options = extend( options || {}, defaults );\n\n      options.element = context.canvas || context;\n      options.element.className += ' sketch';\n\n      extend( context, options, true );\n\n      return constructor( context );\n    }\n  };\n\n  /*\n  ----------------------------------------------------------------------\n\n    Shims\n\n  ----------------------------------------------------------------------\n  */\n\n  var vendors = [ 'ms', 'moz', 'webkit', 'o' ];\n  var scope = self;\n  var then = 0;\n\n  var a = 'AnimationFrame';\n  var b = 'request' + a;\n  var c = 'cancel' + a;\n\n  var rAF = scope[ b ];\n  var cAF = scope[ c ];\n\n  for ( var i = 0; i < vendors.length && !rAF; i++ ) {\n\n    rAF = scope[ vendors[ i ] + 'Request' + a ];\n    cAF = scope[ vendors[ i ] + 'Cancel' + a ];\n  }\n\n  scope[ b ] = rAF = rAF || function( callback ) {\n\n    var now = +new Date();\n    var dt = M.max( 0, 16 - ( now - then ) );\n    var id = setTimeout( function() {\n      callback( now + dt );\n    }, dt );\n\n    then = now + dt;\n    return id;\n  };\n\n  scope[ c ] = cAF = cAF || function( id ) {\n    clearTimeout( id );\n  };\n\n  /*\n  ----------------------------------------------------------------------\n\n    Output\n\n  ----------------------------------------------------------------------\n  */\n\n  return Sketch;\n\n}));\n\n\n//# sourceURL=webpack://Vinyl/./node_modules/sketch-js/js/sketch.js?");

/***/ }),

/***/ "./src/js/storm.js":
/*!*************************!*\
  !*** ./src/js/storm.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var sketch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sketch-js */ \"./node_modules/sketch-js/js/sketch.js\");\n/* harmony import */ var sketch_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sketch_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n(function() {\n    var Building, Skyline, dt, sketch, skylines;\n  \n    sketch = sketch_js__WEBPACK_IMPORTED_MODULE_0___default().create();\n  \n    sketch.mouse.x = sketch.width / 10;\n  \n    sketch.mouse.y = sketch.height;\n  \n    skylines = [];\n  \n    dt = 1;\n  \n    Building = function(config) {\n      return this.reset(config);\n    };\n  \n    Building.prototype.reset = function(config) {\n      this.layer = config.layer;\n      this.x = config.x;\n      this.y = config.y;\n      this.width = config.width;\n      this.height = config.height;\n      this.color = config.color;\n      this.slantedTop = floor(random(0, 10)) === 0;\n      this.slantedTopHeight = this.width / random(2, 4);\n      this.slantedTopDirection = round(random(0, 1)) === 0;\n      this.spireTop = floor(random(0, 15)) === 0;\n      this.spireTopWidth = random(this.width * .01, this.width * .07);\n      this.spireTopHeight = random(10, 20);\n      this.antennaTop = !this.spireTop && floor(random(0, 10)) === 0;\n      this.antennaTopWidth = this.layer / 2;\n      return this.antennaTopHeight = random(5, 20);\n    };\n  \n    Building.prototype.render = function() {\n      sketch.fillStyle = sketch.strokeStyle = this.color;\n      sketch.lineWidth = 2;\n      sketch.beginPath();\n      sketch.rect(this.x, this.y, this.width, this.height);\n      sketch.fill();\n      sketch.stroke();\n      if (this.slantedTop) {\n        sketch.beginPath();\n        sketch.moveTo(this.x, this.y);\n        sketch.lineTo(this.x + this.width, this.y);\n        if (this.slantedTopDirection) {\n          sketch.lineTo(this.x + this.width, this.y - this.slantedTopHeight);\n        } else {\n          sketch.lineTo(this.x, this.y - this.slantedTopHeight);\n        }\n        sketch.closePath();\n        sketch.fill();\n        sketch.stroke();\n      }\n      if (this.spireTop) {\n        sketch.beginPath();\n        sketch.moveTo(this.x + (this.width / 2), this.y - this.spireTopHeight);\n        sketch.lineTo(this.x + (this.width / 2) + this.spireTopWidth, this.y);\n        sketch.lineTo(this.x + (this.width / 2) - this.spireTopWidth, this.y);\n        sketch.closePath();\n        sketch.fill();\n        sketch.stroke();\n      }\n      if (this.antennaTop) {\n        sketch.beginPath();\n        sketch.moveTo(this.x + (this.width / 2), this.y - this.antennaTopHeight);\n        sketch.lineTo(this.x + (this.width / 2), this.y);\n        sketch.lineWidth = this.antennaTopWidth;\n        return sketch.stroke();\n      }\n    };\n  \n    Skyline = function(config) {\n      this.x = 0;\n      this.buildings = [];\n      this.layer = config.layer;\n      this.width = {\n        min: config.width.min,\n        max: config.width.max\n      };\n      this.height = {\n        min: config.height.min,\n        max: config.height.max\n      };\n      this.speed = config.speed;\n      this.color = config.color;\n      this.populate();\n      return this;\n    };\n  \n    Skyline.prototype.populate = function() {\n      var newHeight, newWidth, results, totalWidth;\n      totalWidth = 0;\n      results = [];\n      while (totalWidth <= sketch.width + (this.width.max * 2)) {\n        newWidth = round(random(this.width.min, this.width.max));\n        newHeight = round(random(this.height.min, this.height.max));\n        this.buildings.push(new Building({\n          layer: this.layer,\n          x: this.buildings.length === 0 ? 0 : this.buildings[this.buildings.length - 1].x + this.buildings[this.buildings.length - 1].width,\n          y: sketch.height - newHeight,\n          width: newWidth,\n          height: newHeight,\n          color: this.color\n        }));\n        results.push(totalWidth += newWidth);\n      }\n      return results;\n    };\n  \n    Skyline.prototype.update = function() {\n      var firstBuilding, lastBuilding, newHeight, newWidth;\n      this.x -= (sketch.mouse.x * this.speed) * dt;\n      firstBuilding = this.buildings[0];\n      if (firstBuilding.width + firstBuilding.x + this.x < 0) {\n        newWidth = round(random(this.width.min, this.width.max));\n        newHeight = round(random(this.height.min, this.height.max));\n        lastBuilding = this.buildings[this.buildings.length - 1];\n        firstBuilding.reset({\n          layer: this.layer,\n          x: lastBuilding.x + lastBuilding.width,\n          y: sketch.height - newHeight,\n          width: newWidth,\n          height: newHeight,\n          color: this.color\n        });\n        return this.buildings.push(this.buildings.shift());\n      }\n    };\n  \n    Skyline.prototype.render = function() {\n      var i;\n      i = this.buildings.length;\n      sketch.save();\n      sketch.translate(this.x, (sketch.height - sketch.mouse.y) / 20 * this.layer);\n      while (i--) {\n        this.buildings[i].render(i);\n      }\n      return sketch.restore();\n    };\n  \n    sketch.setup = function() {\n      var i, results;\n      i = 5;\n      results = [];\n      while (i--) {\n        results.push(skylines.push(new Skyline({\n          layer: i + 1,\n          width: {\n            min: (i + 1) * 30,\n            max: (i + 1) * 40\n          },\n          height: {\n            min: 150 - (i * 35),\n            max: 300 - (i * 35)\n          },\n          speed: (i + 1) * .003,\n          color: 'hsl( 200, ' + (((i + 1) * 1) + 10) + '%, ' + (75 - (i * 13)) + '% )'\n        })));\n      }\n      return results;\n    };\n  \n    sketch.clear = function() {\n      return sketch.clearRect(0, 0, sketch.width, sketch.height);\n    };\n  \n    sketch.update = function() {\n      var i, results;\n      dt = sketch.dt < .1 ? .1 : sketch.dt / 16;\n      dt = dt > 5 ? 5 : dt;\n      i = skylines.length;\n      results = [];\n      while (i--) {\n        results.push(skylines[i].update(i));\n      }\n      return results;\n    };\n  \n    sketch.draw = function() {\n      var i, results;\n      i = skylines.length;\n      results = [];\n      while (i--) {\n        results.push(skylines[i].render(i));\n      }\n      return results;\n    };\n  \n    // window.on('mousemove', function(e) {\n    //   sketch.mouse.x = e.pageX;\n    //   return sketch.mouse.y = e.pageY;\n    // }\n    // );\n  \n  }).call(undefined);\n\n//# sourceURL=webpack://Vinyl/./src/js/storm.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/storm.js");
/******/ 	
/******/ })()
;