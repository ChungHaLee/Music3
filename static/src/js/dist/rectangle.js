/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/pts/dist/index.js":
/*!****************************************!*\
  !*** ./node_modules/pts/dist/index.js ***!
  \****************************************/
/***/ ((module) => {

eval("var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/_module.ts\nvar module_exports = {};\n__export(module_exports, {\n  Body: () => Body,\n  Bound: () => Bound,\n  CanvasForm: () => CanvasForm,\n  CanvasSpace: () => CanvasSpace2,\n  Circle: () => Circle,\n  Color: () => Color,\n  Const: () => Const,\n  Create: () => Create,\n  Curve: () => Curve,\n  DOMSpace: () => DOMSpace,\n  Delaunay: () => Delaunay,\n  Font: () => Font,\n  Form: () => Form,\n  Geom: () => Geom,\n  Group: () => Group,\n  HTMLForm: () => HTMLForm,\n  HTMLSpace: () => HTMLSpace,\n  Img: () => Img,\n  Line: () => Line,\n  Mat: () => Mat,\n  MultiTouchSpace: () => MultiTouchSpace,\n  Noise: () => Noise,\n  Num: () => Num,\n  Particle: () => Particle,\n  Polygon: () => Polygon,\n  Pt: () => Pt,\n  Range: () => Range,\n  Rectangle: () => Rectangle,\n  SVGForm: () => SVGForm,\n  SVGSpace: () => SVGSpace,\n  Shaping: () => Shaping,\n  Sound: () => Sound,\n  Space: () => Space,\n  Tempo: () => Tempo,\n  Triangle: () => Triangle,\n  Typography: () => Typography,\n  UI: () => UI,\n  UIButton: () => UIButton,\n  UIDragger: () => UIDragger,\n  UIPointerActions: () => UIPointerActions,\n  UIShape: () => UIShape,\n  Util: () => Util,\n  Vec: () => Vec,\n  VisualForm: () => VisualForm,\n  World: () => World\n});\nmodule.exports = __toCommonJS(module_exports);\n\n// src/LinearAlgebra.ts\nvar Vec = class {\n  static add(a, b) {\n    if (typeof b == \"number\") {\n      for (let i = 0, len = a.length; i < len; i++)\n        a[i] += b;\n    } else {\n      for (let i = 0, len = a.length; i < len; i++)\n        a[i] += b[i] || 0;\n    }\n    return a;\n  }\n  static subtract(a, b) {\n    if (typeof b == \"number\") {\n      for (let i = 0, len = a.length; i < len; i++)\n        a[i] -= b;\n    } else {\n      for (let i = 0, len = a.length; i < len; i++)\n        a[i] -= b[i] || 0;\n    }\n    return a;\n  }\n  static multiply(a, b) {\n    if (typeof b == \"number\") {\n      for (let i = 0, len = a.length; i < len; i++)\n        a[i] *= b;\n    } else {\n      if (a.length != b.length) {\n        throw new Error(`Cannot do element-wise multiply since the array lengths don't match: ${a.toString()} multiply-with ${b.toString()}`);\n      }\n      for (let i = 0, len = a.length; i < len; i++)\n        a[i] *= b[i];\n    }\n    return a;\n  }\n  static divide(a, b) {\n    if (typeof b == \"number\") {\n      if (b === 0)\n        throw new Error(\"Cannot divide by zero\");\n      for (let i = 0, len = a.length; i < len; i++)\n        a[i] /= b;\n    } else {\n      if (a.length != b.length) {\n        throw new Error(`Cannot do element-wise divide since the array lengths don't match. ${a.toString()} divide-by ${b.toString()}`);\n      }\n      for (let i = 0, len = a.length; i < len; i++)\n        a[i] /= b[i];\n    }\n    return a;\n  }\n  static dot(a, b) {\n    if (a.length != b.length)\n      throw new Error(\"Array lengths don't match\");\n    let d = 0;\n    for (let i = 0, len = a.length; i < len; i++) {\n      d += a[i] * b[i];\n    }\n    return d;\n  }\n  static cross2D(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n  }\n  static cross(a, b) {\n    return new Pt(a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]);\n  }\n  static magnitude(a) {\n    return Math.sqrt(Vec.dot(a, a));\n  }\n  static unit(a, magnitude = void 0) {\n    let m = magnitude === void 0 ? Vec.magnitude(a) : magnitude;\n    if (m === 0)\n      return Pt.make(a.length);\n    return Vec.divide(a, m);\n  }\n  static abs(a) {\n    return Vec.map(a, Math.abs);\n  }\n  static floor(a) {\n    return Vec.map(a, Math.floor);\n  }\n  static ceil(a) {\n    return Vec.map(a, Math.ceil);\n  }\n  static round(a) {\n    return Vec.map(a, Math.round);\n  }\n  static max(a) {\n    let m = Number.MIN_VALUE;\n    let index = 0;\n    for (let i = 0, len = a.length; i < len; i++) {\n      m = Math.max(m, a[i]);\n      if (m === a[i])\n        index = i;\n    }\n    return { value: m, index };\n  }\n  static min(a) {\n    let m = Number.MAX_VALUE;\n    let index = 0;\n    for (let i = 0, len = a.length; i < len; i++) {\n      m = Math.min(m, a[i]);\n      if (m === a[i])\n        index = i;\n    }\n    return { value: m, index };\n  }\n  static sum(a) {\n    let s = 0;\n    for (let i = 0, len = a.length; i < len; i++)\n      s += a[i];\n    return s;\n  }\n  static map(a, fn) {\n    for (let i = 0, len = a.length; i < len; i++) {\n      a[i] = fn(a[i], i, a);\n    }\n    return a;\n  }\n};\nvar Mat = class {\n  constructor() {\n    this.reset();\n  }\n  get value() {\n    return this._33;\n  }\n  get domMatrix() {\n    return new DOMMatrix(Mat.toDOMMatrix(this._33));\n  }\n  reset() {\n    this._33 = Mat.scale2DMatrix(1, 1);\n  }\n  scale2D(val, at = [0, 0]) {\n    const m = Mat.scaleAt2DMatrix(val[0] || 1, val[1] || 1, at);\n    this._33 = Mat.multiply(this._33, m);\n    return this;\n  }\n  rotate2D(ang, at = [0, 0]) {\n    const m = Mat.rotateAt2DMatrix(Math.cos(ang), Math.sin(ang), at);\n    this._33 = Mat.multiply(this._33, m);\n    return this;\n  }\n  translate2D(val) {\n    const m = Mat.translate2DMatrix(val[0] || 0, val[1] || 0);\n    this._33 = Mat.multiply(this._33, m);\n    return this;\n  }\n  shear2D(val, at = [0, 0]) {\n    const m = Mat.shearAt2DMatrix(Math.tan(val[0] || 0), Math.tan(val[1] || 1), at);\n    this._33 = Mat.multiply(this._33, m);\n    return this;\n  }\n  static add(a, b) {\n    if (typeof b != \"number\") {\n      if (a[0].length != b[0].length)\n        throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n      if (a.length != b.length)\n        throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n    }\n    let g = new Group();\n    let isNum = typeof b == \"number\";\n    for (let i = 0, len = a.length; i < len; i++) {\n      g.push(a[i].$add(isNum ? b : b[i]));\n    }\n    return g;\n  }\n  static multiply(a, b, transposed = false, elementwise = false) {\n    let g = new Group();\n    if (typeof b != \"number\") {\n      if (elementwise) {\n        if (a.length != b.length)\n          throw new Error(\"Cannot multiply matrix element-wise because the matrices' sizes don't match.\");\n        for (let ai = 0, alen = a.length; ai < alen; ai++) {\n          g.push(a[ai].$multiply(b[ai]));\n        }\n      } else {\n        if (!transposed && a[0].length != b.length)\n          throw new Error(\"Cannot multiply matrix if rows in matrix-a don't match columns in matrix-b.\");\n        if (transposed && a[0].length != b[0].length)\n          throw new Error(\"Cannot multiply matrix if transposed and the columns in both matrices don't match.\");\n        if (!transposed)\n          b = Mat.transpose(b);\n        for (let ai = 0, alen = a.length; ai < alen; ai++) {\n          let p = Pt.make(b.length, 0);\n          for (let bi = 0, blen = b.length; bi < blen; bi++) {\n            p[bi] = Vec.dot(a[ai], b[bi]);\n          }\n          g.push(p);\n        }\n      }\n    } else {\n      for (let ai = 0, alen = a.length; ai < alen; ai++) {\n        g.push(a[ai].$multiply(b));\n      }\n    }\n    return g;\n  }\n  static zipSlice(g, index, defaultValue = false) {\n    let z = [];\n    for (let i = 0, len = g.length; i < len; i++) {\n      if (g[i].length - 1 < index && defaultValue === false)\n        throw `Index ${index} is out of bounds`;\n      z.push(g[i][index] || defaultValue);\n    }\n    return new Pt(z);\n  }\n  static zip(g, defaultValue = false, useLongest = false) {\n    let ps = new Group();\n    let len = useLongest ? g.reduce((a, b) => Math.max(a, b.length), 0) : g[0].length;\n    for (let i = 0; i < len; i++) {\n      ps.push(Mat.zipSlice(g, i, defaultValue));\n    }\n    return ps;\n  }\n  static transpose(g, defaultValue = false, useLongest = false) {\n    return Mat.zip(g, defaultValue, useLongest);\n  }\n  static toDOMMatrix(m) {\n    return [m[0][0], m[0][1], m[1][0], m[1][1], m[2][0], m[2][1]];\n  }\n  static transform2D(pt, m) {\n    let x = pt[0] * m[0][0] + pt[1] * m[1][0] + m[2][0];\n    let y = pt[0] * m[0][1] + pt[1] * m[1][1] + m[2][1];\n    return new Pt(x, y);\n  }\n  static scale2DMatrix(x, y) {\n    return new Group(\n      new Pt(x, 0, 0),\n      new Pt(0, y, 0),\n      new Pt(0, 0, 1)\n    );\n  }\n  static rotate2DMatrix(cosA, sinA) {\n    return new Group(\n      new Pt(cosA, sinA, 0),\n      new Pt(-sinA, cosA, 0),\n      new Pt(0, 0, 1)\n    );\n  }\n  static shear2DMatrix(tanX, tanY) {\n    return new Group(\n      new Pt(1, tanX, 0),\n      new Pt(tanY, 1, 0),\n      new Pt(0, 0, 1)\n    );\n  }\n  static translate2DMatrix(x, y) {\n    return new Group(\n      new Pt(1, 0, 0),\n      new Pt(0, 1, 0),\n      new Pt(x, y, 1)\n    );\n  }\n  static scaleAt2DMatrix(sx, sy, at) {\n    let m = Mat.scale2DMatrix(sx, sy);\n    m[2][0] = -at[0] * sx + at[0];\n    m[2][1] = -at[1] * sy + at[1];\n    return m;\n  }\n  static rotateAt2DMatrix(cosA, sinA, at) {\n    let m = Mat.rotate2DMatrix(cosA, sinA);\n    m[2][0] = at[0] * (1 - cosA) + at[1] * sinA;\n    m[2][1] = at[1] * (1 - cosA) - at[0] * sinA;\n    return m;\n  }\n  static shearAt2DMatrix(tanX, tanY, at) {\n    let m = Mat.shear2DMatrix(tanX, tanY);\n    m[2][0] = -at[1] * tanY;\n    m[2][1] = -at[0] * tanX;\n    return m;\n  }\n  static reflectAt2DMatrix(p1, p2) {\n    let intercept = Line.intercept(p1, p2);\n    if (intercept == void 0) {\n      return [\n        new Pt([-1, 0, 0]),\n        new Pt([0, 1, 0]),\n        new Pt([p1[0] + p2[0], 0, 1])\n      ];\n    } else {\n      let yi = intercept.yi;\n      let ang2 = Math.atan(intercept.slope) * 2;\n      let cosA = Math.cos(ang2);\n      let sinA = Math.sin(ang2);\n      return [\n        new Pt([cosA, sinA, 0]),\n        new Pt([sinA, -cosA, 0]),\n        new Pt([-yi * sinA, yi + yi * cosA, 1])\n      ];\n    }\n  }\n};\n\n// src/Op.ts\nvar _errorLength = (obj, param = \"expected\") => Util.warn(\"Group's length is less than \" + param, obj);\nvar _errorOutofBound = (obj, param = \"\") => Util.warn(`Index ${param} is out of bound in Group`, obj);\nvar Line = class {\n  static fromAngle(anchor, angle, magnitude) {\n    let g = new Group(new Pt(anchor), new Pt(anchor));\n    g[1].toAngle(angle, magnitude, true);\n    return g;\n  }\n  static slope(p1, p2) {\n    return p2[0] - p1[0] === 0 ? void 0 : (p2[1] - p1[1]) / (p2[0] - p1[0]);\n  }\n  static intercept(p1, p2) {\n    if (p2[0] - p1[0] === 0) {\n      return void 0;\n    } else {\n      let m = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n      let c = p1[1] - m * p1[0];\n      return { slope: m, yi: c, xi: m === 0 ? void 0 : -c / m };\n    }\n  }\n  static sideOfPt2D(line, pt) {\n    let _line = Util.iterToArray(line);\n    return (_line[1][0] - _line[0][0]) * (pt[1] - _line[0][1]) - (pt[0] - _line[0][0]) * (_line[1][1] - _line[0][1]);\n  }\n  static collinear(p1, p2, p3, threshold = 0.01) {\n    let a = new Pt(0, 0, 0).to(p1).$subtract(p2);\n    let b = new Pt(0, 0, 0).to(p1).$subtract(p3);\n    return a.$cross(b).divide(1e3).equals(new Pt(0, 0, 0), threshold);\n  }\n  static magnitude(line) {\n    let _line = Util.iterToArray(line);\n    return _line.length >= 2 ? _line[1].$subtract(_line[0]).magnitude() : 0;\n  }\n  static magnitudeSq(line) {\n    let _line = Util.iterToArray(line);\n    return _line.length >= 2 ? _line[1].$subtract(_line[0]).magnitudeSq() : 0;\n  }\n  static perpendicularFromPt(line, pt, asProjection = false) {\n    let _line = Util.iterToArray(line);\n    if (_line[0].equals(_line[1]))\n      return void 0;\n    let a = _line[0].$subtract(_line[1]);\n    let b = _line[1].$subtract(pt);\n    let proj = b.$subtract(a.$project(b));\n    return asProjection ? proj : proj.$add(pt);\n  }\n  static distanceFromPt(line, pt) {\n    let _line = Util.iterToArray(line);\n    let projectionVector = Line.perpendicularFromPt(_line, pt, true);\n    if (projectionVector) {\n      return projectionVector.magnitude();\n    } else {\n      return _line[0].$subtract(pt).magnitude();\n    }\n  }\n  static intersectRay2D(la, lb) {\n    let _la = Util.iterToArray(la);\n    let _lb = Util.iterToArray(lb);\n    let a = Line.intercept(_la[0], _la[1]);\n    let b = Line.intercept(_lb[0], _lb[1]);\n    let pa = _la[0];\n    let pb = _lb[0];\n    if (a == void 0) {\n      if (b == void 0)\n        return void 0;\n      let y1 = -b.slope * (pb[0] - pa[0]) + pb[1];\n      return new Pt(pa[0], y1);\n    } else {\n      if (b == void 0) {\n        let y1 = -a.slope * (pa[0] - pb[0]) + pa[1];\n        return new Pt(pb[0], y1);\n      } else if (b.slope != a.slope) {\n        let px = (a.slope * pa[0] - b.slope * pb[0] + pb[1] - pa[1]) / (a.slope - b.slope);\n        let py = a.slope * (px - pa[0]) + pa[1];\n        return new Pt(px, py);\n      } else {\n        if (a.yi == b.yi) {\n          return new Pt(pa[0], pa[1]);\n        } else {\n          return void 0;\n        }\n      }\n    }\n  }\n  static intersectLine2D(la, lb) {\n    let _la = Util.iterToArray(la);\n    let _lb = Util.iterToArray(lb);\n    let pt = Line.intersectRay2D(_la, _lb);\n    return pt && Geom.withinBound(pt, _la[0], _la[1]) && Geom.withinBound(pt, _lb[0], _lb[1]) ? pt : void 0;\n  }\n  static intersectLineWithRay2D(line, ray) {\n    let _line = Util.iterToArray(line);\n    let _ray = Util.iterToArray(ray);\n    let pt = Line.intersectRay2D(_line, _ray);\n    return pt && Geom.withinBound(pt, _line[0], _line[1]) ? pt : void 0;\n  }\n  static intersectPolygon2D(lineOrRay, poly, sourceIsRay = false) {\n    let _lineOrRay = Util.iterToArray(lineOrRay);\n    let _poly = Util.iterToArray(poly);\n    let fn = sourceIsRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n    let pts = new Group();\n    for (let i = 0, len = _poly.length; i < len; i++) {\n      let next = i === len - 1 ? 0 : i + 1;\n      let d = fn([_poly[i], _poly[next]], _lineOrRay);\n      if (d)\n        pts.push(d);\n    }\n    return pts.length > 0 ? pts : void 0;\n  }\n  static intersectLines2D(lines1, lines2, isRay = false) {\n    let group = new Group();\n    let fn = isRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n    for (let l1 of lines1) {\n      for (let l2 of lines2) {\n        let _ip = fn(l1, l2);\n        if (_ip)\n          group.push(_ip);\n      }\n    }\n    return group;\n  }\n  static intersectGridWithRay2D(ray, gridPt) {\n    let _ray = Util.iterToArray(ray);\n    let t = Line.intercept(new Pt(_ray[0]).subtract(gridPt), new Pt(_ray[1]).subtract(gridPt));\n    let g = new Group();\n    if (t && t.xi)\n      g.push(new Pt(gridPt[0] + t.xi, gridPt[1]));\n    if (t && t.yi)\n      g.push(new Pt(gridPt[0], gridPt[1] + t.yi));\n    return g;\n  }\n  static intersectGridWithLine2D(line, gridPt) {\n    let _line = Util.iterToArray(line);\n    let g = Line.intersectGridWithRay2D(_line, gridPt);\n    let gg = new Group();\n    for (let i = 0, len = g.length; i < len; i++) {\n      if (Geom.withinBound(g[i], _line[0], _line[1]))\n        gg.push(g[i]);\n    }\n    return gg;\n  }\n  static intersectRect2D(line, rect) {\n    let _line = Util.iterToArray(line);\n    let _rect = Util.iterToArray(rect);\n    let box = Geom.boundingBox(Group.fromPtArray(_line));\n    if (!Rectangle.hasIntersectRect2D(box, _rect))\n      return new Group();\n    return Line.intersectLines2D([_line], Rectangle.sides(_rect));\n  }\n  static subpoints(line, num) {\n    let _line = Util.iterToArray(line);\n    let pts = new Group();\n    for (let i = 1; i <= num; i++) {\n      pts.push(Geom.interpolate(_line[0], _line[1], i / (num + 1)));\n    }\n    return pts;\n  }\n  static crop(line, size, index = 0, cropAsCircle = true) {\n    let _line = Util.iterToArray(line);\n    let tdx = index === 0 ? 1 : 0;\n    let ls = _line[tdx].$subtract(_line[index]);\n    if (ls[0] === 0 || size[0] === 0)\n      return _line[index];\n    if (cropAsCircle) {\n      let d = ls.unit().multiply(size[1]);\n      return _line[index].$add(d);\n    } else {\n      let rect = Rectangle.fromCenter(_line[index], size);\n      let sides = Rectangle.sides(rect);\n      let sideIdx = 0;\n      if (Math.abs(ls[1] / ls[0]) > Math.abs(size[1] / size[0])) {\n        sideIdx = ls[1] < 0 ? 0 : 2;\n      } else {\n        sideIdx = ls[0] < 0 ? 3 : 1;\n      }\n      return Line.intersectRay2D(sides[sideIdx], _line);\n    }\n  }\n  static marker(line, size, graphic = \"arrow\", atTail = true) {\n    let _line = Util.iterToArray(line);\n    let h = atTail ? 0 : 1;\n    let t = atTail ? 1 : 0;\n    let unit = _line[h].$subtract(_line[t]);\n    if (unit.magnitudeSq() === 0)\n      return new Group();\n    unit.unit();\n    let ps = Geom.perpendicular(unit).multiply(size[0]).add(_line[t]);\n    if (graphic == \"arrow\") {\n      ps.add(unit.$multiply(size[1]));\n      return new Group(_line[t], ps[0], ps[1]);\n    } else {\n      return new Group(ps[0], ps[1]);\n    }\n  }\n  static toRect(line) {\n    let _line = Util.iterToArray(line);\n    return new Group(_line[0].$min(_line[1]), _line[0].$max(_line[1]));\n  }\n};\nvar Rectangle = class {\n  static from(topLeft, widthOrSize, height) {\n    return Rectangle.fromTopLeft(topLeft, widthOrSize, height);\n  }\n  static fromTopLeft(topLeft, widthOrSize, height) {\n    let size = typeof widthOrSize == \"number\" ? [widthOrSize, height || widthOrSize] : widthOrSize;\n    return new Group(new Pt(topLeft), new Pt(topLeft).add(size));\n  }\n  static fromCenter(center, widthOrSize, height) {\n    let half = typeof widthOrSize == \"number\" ? [widthOrSize / 2, (height || widthOrSize) / 2] : new Pt(widthOrSize).divide(2);\n    return new Group(new Pt(center).subtract(half), new Pt(center).add(half));\n  }\n  static toCircle(pts, within = true) {\n    return Circle.fromRect(pts, within);\n  }\n  static toSquare(pts, enclose = false) {\n    let _pts = Util.iterToArray(pts);\n    let s = Rectangle.size(_pts);\n    let m = enclose ? s.maxValue().value : s.minValue().value;\n    return Rectangle.fromCenter(Rectangle.center(_pts), m, m);\n  }\n  static size(pts) {\n    let p = Util.iterToArray(pts);\n    return p[0].$max(p[1]).subtract(p[0].$min(p[1]));\n  }\n  static center(pts) {\n    let p = Util.iterToArray(pts);\n    let min = p[0].$min(p[1]);\n    let max = p[0].$max(p[1]);\n    return min.add(max.$subtract(min).divide(2));\n  }\n  static corners(rect) {\n    let _rect = Util.iterToArray(rect);\n    let p0 = _rect[0].$min(_rect[1]);\n    let p2 = _rect[0].$max(_rect[1]);\n    return new Group(p0, new Pt(p2.x, p0.y), p2, new Pt(p0.x, p2.y));\n  }\n  static sides(rect) {\n    let [p0, p1, p2, p3] = Rectangle.corners(rect);\n    return [\n      new Group(p0, p1),\n      new Group(p1, p2),\n      new Group(p2, p3),\n      new Group(p3, p0)\n    ];\n  }\n  static boundingBox(rects) {\n    let _rects = Util.iterToArray(rects);\n    let merged = Util.flatten(_rects, false);\n    let min = Pt.make(2, Number.MAX_VALUE);\n    let max = Pt.make(2, Number.MIN_VALUE);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      let k = 0;\n      for (let m of merged[i]) {\n        min[k] = Math.min(min[k], m[k]);\n        max[k] = Math.max(max[k], m[k]);\n        if (++k >= 2)\n          break;\n      }\n    }\n    return new Group(min, max);\n  }\n  static polygon(rect) {\n    return Rectangle.corners(rect);\n  }\n  static quadrants(rect, center) {\n    let _rect = Util.iterToArray(rect);\n    let corners = Rectangle.corners(_rect);\n    let _center = center != void 0 ? new Pt(center) : Rectangle.center(_rect);\n    return corners.map((c) => new Group(c, _center).boundingBox());\n  }\n  static halves(rect, ratio = 0.5, asRows = false) {\n    let _rect = Util.iterToArray(rect);\n    let min = _rect[0].$min(_rect[1]);\n    let max = _rect[0].$max(_rect[1]);\n    let mid = asRows ? Num.lerp(min[1], max[1], ratio) : Num.lerp(min[0], max[0], ratio);\n    return asRows ? [new Group(min, new Pt(max[0], mid)), new Group(new Pt(min[0], mid), max)] : [new Group(min, new Pt(mid, max[1])), new Group(new Pt(mid, min[1]), max)];\n  }\n  static withinBound(rect, pt) {\n    let _rect = Util.iterToArray(rect);\n    return Geom.withinBound(pt, _rect[0], _rect[1]);\n  }\n  static hasIntersectRect2D(rect1, rect2, resetBoundingBox = false) {\n    let _rect1 = Util.iterToArray(rect1);\n    let _rect2 = Util.iterToArray(rect2);\n    if (resetBoundingBox) {\n      _rect1 = Geom.boundingBox(_rect1);\n      _rect2 = Geom.boundingBox(_rect2);\n    }\n    if (_rect1[0][0] > _rect2[1][0] || _rect2[0][0] > _rect1[1][0])\n      return false;\n    if (_rect1[0][1] > _rect2[1][1] || _rect2[0][1] > _rect1[1][1])\n      return false;\n    return true;\n  }\n  static intersectRect2D(rect1, rect2) {\n    let _rect1 = Util.iterToArray(rect1);\n    let _rect2 = Util.iterToArray(rect2);\n    if (!Rectangle.hasIntersectRect2D(_rect1, _rect2))\n      return new Group();\n    return Line.intersectLines2D(Rectangle.sides(_rect1), Rectangle.sides(_rect2));\n  }\n};\nvar Circle = class {\n  static fromRect(pts, enclose = false) {\n    let _pts = Util.iterToArray(pts);\n    let r = 0;\n    let min = r = Rectangle.size(_pts).minValue().value / 2;\n    if (enclose) {\n      let max = Rectangle.size(_pts).maxValue().value / 2;\n      r = Math.sqrt(min * min + max * max);\n    } else {\n      r = min;\n    }\n    return new Group(Rectangle.center(_pts), new Pt(r, r));\n  }\n  static fromTriangle(pts, enclose = false) {\n    if (enclose) {\n      return Triangle.circumcircle(pts);\n    } else {\n      return Triangle.incircle(pts);\n    }\n  }\n  static fromCenter(pt, radius) {\n    return new Group(new Pt(pt), new Pt(radius, radius));\n  }\n  static withinBound(pts, pt, threshold = 0) {\n    let _pts = Util.iterToArray(pts);\n    let d = _pts[0].$subtract(pt);\n    return d.dot(d) + threshold < _pts[1].x * _pts[1].x;\n  }\n  static intersectRay2D(circle, ray) {\n    let _pts = Util.iterToArray(circle);\n    let _ray = Util.iterToArray(ray);\n    let d = _ray[0].$subtract(_ray[1]);\n    let f = _pts[0].$subtract(_ray[0]);\n    let a = d.dot(d);\n    let b = f.dot(d);\n    let c = f.dot(f) - _pts[1].x * _pts[1].x;\n    let p = b / a;\n    let q = c / a;\n    let disc = p * p - q;\n    if (disc < 0) {\n      return new Group();\n    } else {\n      let discSqrt = Math.sqrt(disc);\n      let t1 = -p + discSqrt;\n      let p1 = _ray[0].$subtract(d.$multiply(t1));\n      if (disc === 0)\n        return new Group(p1);\n      let t2 = -p - discSqrt;\n      let p2 = _ray[0].$subtract(d.$multiply(t2));\n      return new Group(p1, p2);\n    }\n  }\n  static intersectLine2D(circle, line) {\n    let _pts = Util.iterToArray(circle);\n    let _line = Util.iterToArray(line);\n    let ps = Circle.intersectRay2D(_pts, _line);\n    let g = new Group();\n    if (ps.length > 0) {\n      for (let i = 0, len = ps.length; i < len; i++) {\n        if (Rectangle.withinBound(_line, ps[i]))\n          g.push(ps[i]);\n      }\n    }\n    return g;\n  }\n  static intersectCircle2D(circle1, circle2) {\n    let _pts = Util.iterToArray(circle1);\n    let _circle = Util.iterToArray(circle2);\n    let dv = _circle[0].$subtract(_pts[0]);\n    let dr2 = dv.magnitudeSq();\n    let dr = Math.sqrt(dr2);\n    let ar = _pts[1].x;\n    let br = _circle[1].x;\n    let ar2 = ar * ar;\n    let br2 = br * br;\n    if (dr > ar + br) {\n      return new Group();\n    } else if (dr < Math.abs(ar - br)) {\n      return new Group(_pts[0].clone());\n    } else {\n      let a = (ar2 - br2 + dr2) / (2 * dr);\n      let h = Math.sqrt(ar2 - a * a);\n      let p = dv.$multiply(a / dr).add(_pts[0]);\n      return new Group(\n        new Pt(p.x + h * dv.y / dr, p.y - h * dv.x / dr),\n        new Pt(p.x - h * dv.y / dr, p.y + h * dv.x / dr)\n      );\n    }\n  }\n  static intersectRect2D(circle, rect) {\n    let _pts = Util.iterToArray(circle);\n    let _rect = Util.iterToArray(rect);\n    let sides = Rectangle.sides(_rect);\n    let g = [];\n    for (let i = 0, len = sides.length; i < len; i++) {\n      let ps = Circle.intersectLine2D(_pts, sides[i]);\n      if (ps.length > 0)\n        g.push(ps);\n    }\n    return Util.flatten(g);\n  }\n  static toRect(circle, within = false) {\n    let _pts = Util.iterToArray(circle);\n    let r = _pts[1][0];\n    if (within) {\n      let half = Math.sqrt(r * r) / 2;\n      return new Group(_pts[0].$subtract(half), _pts[0].$add(half));\n    } else {\n      return new Group(_pts[0].$subtract(r), _pts[0].$add(r));\n    }\n  }\n  static toTriangle(circle, within = true) {\n    let _pts = Util.iterToArray(circle);\n    if (within) {\n      let ang = -Math.PI / 2;\n      let inc = Math.PI * 2 / 3;\n      let g = new Group();\n      for (let i = 0; i < 3; i++) {\n        g.push(_pts[0].clone().toAngle(ang, _pts[1][0], true));\n        ang += inc;\n      }\n      return g;\n    } else {\n      return Triangle.fromCenter(_pts[0], _pts[1][0]);\n    }\n  }\n};\nvar Triangle = class {\n  static fromRect(rect) {\n    let _rect = Util.iterToArray(rect);\n    let top = _rect[0].$add(_rect[1]).divide(2);\n    top.y = _rect[0][1];\n    let left = _rect[1].clone();\n    left.x = _rect[0][0];\n    return new Group(top, _rect[1].clone(), left);\n  }\n  static fromCircle(circle) {\n    return Circle.toTriangle(circle, true);\n  }\n  static fromCenter(pt, size) {\n    return Triangle.fromCircle(Circle.fromCenter(pt, size));\n  }\n  static medial(tri) {\n    let _pts = Util.iterToArray(tri);\n    if (_pts.length < 3)\n      return _errorLength(new Group(), 3);\n    return Polygon.midpoints(_pts, true);\n  }\n  static oppositeSide(tri, index) {\n    let _pts = Util.iterToArray(tri);\n    if (_pts.length < 3)\n      return _errorLength(new Group(), 3);\n    if (index === 0) {\n      return Group.fromPtArray([_pts[1], _pts[2]]);\n    } else if (index === 1) {\n      return Group.fromPtArray([_pts[0], _pts[2]]);\n    } else {\n      return Group.fromPtArray([_pts[0], _pts[1]]);\n    }\n  }\n  static altitude(tri, index) {\n    let _pts = Util.iterToArray(tri);\n    let opp = Triangle.oppositeSide(_pts, index);\n    if (opp.length > 1) {\n      return new Group(_pts[index], Line.perpendicularFromPt(opp, _pts[index]));\n    } else {\n      return new Group();\n    }\n  }\n  static orthocenter(tri) {\n    let _pts = Util.iterToArray(tri);\n    if (_pts.length < 3)\n      return _errorLength(void 0, 3);\n    let a = Triangle.altitude(_pts, 0);\n    let b = Triangle.altitude(_pts, 1);\n    return Line.intersectRay2D(a, b);\n  }\n  static incenter(tri) {\n    let _pts = Util.iterToArray(tri);\n    if (_pts.length < 3)\n      return _errorLength(void 0, 3);\n    let a = Polygon.bisector(_pts, 0).add(_pts[0]);\n    let b = Polygon.bisector(_pts, 1).add(_pts[1]);\n    return Line.intersectRay2D(new Group(_pts[0], a), new Group(_pts[1], b));\n  }\n  static incircle(tri, center) {\n    let _pts = Util.iterToArray(tri);\n    let c = center ? center : Triangle.incenter(_pts);\n    let area = Polygon.area(_pts);\n    let perim = Polygon.perimeter(_pts, true);\n    let r = 2 * area / perim.total;\n    return Circle.fromCenter(c, r);\n  }\n  static circumcenter(tri) {\n    let _pts = Util.iterToArray(tri);\n    let md = Triangle.medial(_pts);\n    let a = [md[0], Geom.perpendicular(_pts[0].$subtract(md[0])).p1.$add(md[0])];\n    let b = [md[1], Geom.perpendicular(_pts[1].$subtract(md[1])).p1.$add(md[1])];\n    return Line.intersectRay2D(a, b);\n  }\n  static circumcircle(tri, center) {\n    let _pts = Util.iterToArray(tri);\n    let c = center ? center : Triangle.circumcenter(_pts);\n    let r = _pts[0].$subtract(c).magnitude();\n    return Circle.fromCenter(c, r);\n  }\n};\nvar Polygon = class {\n  static centroid(pts) {\n    return Geom.centroid(pts);\n  }\n  static rectangle(center, widthOrSize, height) {\n    return Rectangle.corners(Rectangle.fromCenter(center, widthOrSize, height));\n  }\n  static fromCenter(center, radius, sides) {\n    let g = new Group();\n    for (let i = 0; i < sides; i++) {\n      let ang = Math.PI * 2 * i / sides;\n      g.push(new Pt(Math.cos(ang) * radius, Math.sin(ang) * radius).add(center));\n    }\n    return g;\n  }\n  static lineAt(pts, index) {\n    let _pts = Util.iterToArray(pts);\n    if (index < 0 || index >= _pts.length)\n      throw new Error(\"index out of the Polygon's range\");\n    return new Group(_pts[index], index === _pts.length - 1 ? _pts[0] : _pts[index + 1]);\n  }\n  static lines(poly, closePath = true) {\n    let _pts = Util.iterToArray(poly);\n    if (_pts.length < 2)\n      return _errorLength(new Group(), 2);\n    let sp = Util.split(_pts, 2, 1);\n    if (closePath)\n      sp.push(new Group(_pts[_pts.length - 1], _pts[0]));\n    return sp.map((g) => g);\n  }\n  static midpoints(poly, closePath = false, t = 0.5) {\n    let sides = Polygon.lines(poly, closePath);\n    let mids = sides.map((s) => Geom.interpolate(s[0], s[1], t));\n    return mids;\n  }\n  static adjacentSides(poly, index, closePath = false) {\n    let _pts = Util.iterToArray(poly);\n    if (_pts.length < 2)\n      return _errorLength(new Group(), 2);\n    if (index < 0 || index >= _pts.length)\n      return _errorOutofBound(new Group(), index);\n    let gs = [];\n    let left = index - 1;\n    if (closePath && left < 0)\n      left = _pts.length - 1;\n    if (left >= 0)\n      gs.push(new Group(_pts[index], _pts[left]));\n    let right = index + 1;\n    if (closePath && right > _pts.length - 1)\n      right = 0;\n    if (right <= _pts.length - 1)\n      gs.push(new Group(_pts[index], _pts[right]));\n    return gs;\n  }\n  static bisector(poly, index) {\n    let sides = Polygon.adjacentSides(poly, index, true);\n    if (sides.length >= 2) {\n      let a = sides[0][1].$subtract(sides[0][0]).unit();\n      let b = sides[1][1].$subtract(sides[1][0]).unit();\n      return a.add(b).divide(2);\n    } else {\n      return void 0;\n    }\n  }\n  static perimeter(poly, closePath = false) {\n    let lines = Polygon.lines(poly, closePath);\n    let mag = 0;\n    let p = Pt.make(lines.length, 0);\n    for (let i = 0, len = lines.length; i < len; i++) {\n      let m = Line.magnitude(lines[i]);\n      mag += m;\n      p[i] = m;\n    }\n    return {\n      total: mag,\n      segments: p\n    };\n  }\n  static area(pts) {\n    let _pts = Util.iterToArray(pts);\n    if (_pts.length < 3)\n      return _errorLength(new Group(), 3);\n    let det = (a, b) => a[0] * b[1] - a[1] * b[0];\n    let area = 0;\n    for (let i = 0, len = _pts.length; i < len; i++) {\n      if (i < _pts.length - 1) {\n        area += det(_pts[i], _pts[i + 1]);\n      } else {\n        area += det(_pts[i], _pts[0]);\n      }\n    }\n    return Math.abs(area / 2);\n  }\n  static convexHull(pts, sorted = false) {\n    let _pts = Util.iterToArray(pts);\n    if (_pts.length < 3)\n      return _errorLength(new Group(), 3);\n    if (!sorted) {\n      _pts = _pts.slice();\n      _pts.sort((a, b) => a[0] - b[0]);\n    }\n    let left = (a, b, c) => {\n      return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) > 0;\n    };\n    let dq = [];\n    let bot = _pts.length - 2;\n    let top = bot + 3;\n    dq[bot] = _pts[2];\n    dq[top] = _pts[2];\n    if (left(_pts[0], _pts[1], _pts[2])) {\n      dq[bot + 1] = _pts[0];\n      dq[bot + 2] = _pts[1];\n    } else {\n      dq[bot + 1] = _pts[1];\n      dq[bot + 2] = _pts[0];\n    }\n    for (let i = 3, len = _pts.length; i < len; i++) {\n      let pt = _pts[i];\n      if (left(dq[bot], dq[bot + 1], pt) && left(dq[top - 1], dq[top], pt)) {\n        continue;\n      }\n      while (!left(dq[bot], dq[bot + 1], pt)) {\n        bot += 1;\n      }\n      bot -= 1;\n      dq[bot] = pt;\n      while (!left(dq[top - 1], dq[top], pt)) {\n        top -= 1;\n      }\n      top += 1;\n      dq[top] = pt;\n    }\n    let hull = new Group();\n    for (let h = 0; h < top - bot; h++) {\n      hull.push(dq[bot + h]);\n    }\n    return hull;\n  }\n  static network(poly, originIndex = 0) {\n    let _pts = Util.iterToArray(poly);\n    let g = [];\n    for (let i = 0, len = _pts.length; i < len; i++) {\n      if (i != originIndex)\n        g.push(new Group(_pts[originIndex], _pts[i]));\n    }\n    return g;\n  }\n  static nearestPt(poly, pt) {\n    let _near = Number.MAX_VALUE;\n    let _item = -1;\n    let i = 0;\n    for (let p of poly) {\n      let d = p.$subtract(pt).magnitudeSq();\n      if (d < _near) {\n        _near = d;\n        _item = i;\n      }\n      i++;\n    }\n    return _item;\n  }\n  static projectAxis(poly, unitAxis) {\n    let _poly = Util.iterToArray(poly);\n    let dot = unitAxis.dot(_poly[0]);\n    let d = new Pt(dot, dot);\n    for (let n = 1, len = _poly.length; n < len; n++) {\n      dot = unitAxis.dot(_poly[n]);\n      d = new Pt(Math.min(dot, d[0]), Math.max(dot, d[1]));\n    }\n    return d;\n  }\n  static _axisOverlap(poly1, poly2, unitAxis) {\n    let pa = Polygon.projectAxis(poly1, unitAxis);\n    let pb = Polygon.projectAxis(poly2, unitAxis);\n    return pa[0] < pb[0] ? pb[0] - pa[1] : pa[0] - pb[1];\n  }\n  static hasIntersectPoint(poly, pt) {\n    let _poly = Util.iterToArray(poly);\n    let c = false;\n    for (let i = 0, len = _poly.length; i < len; i++) {\n      let ln = Polygon.lineAt(_poly, i);\n      if (ln[0][1] > pt[1] != ln[1][1] > pt[1] && pt[0] < (ln[1][0] - ln[0][0]) * (pt[1] - ln[0][1]) / (ln[1][1] - ln[0][1]) + ln[0][0]) {\n        c = !c;\n      }\n    }\n    return c;\n  }\n  static hasIntersectCircle(poly, circle) {\n    let _poly = Util.iterToArray(poly);\n    let _circle = Util.iterToArray(circle);\n    let info = {\n      which: -1,\n      dist: 0,\n      normal: null,\n      edge: null,\n      vertex: null\n    };\n    let c = _circle[0];\n    let r = _circle[1][0];\n    let minDist = Number.MAX_SAFE_INTEGER;\n    for (let i = 0, len = _poly.length; i < len; i++) {\n      let edge = Polygon.lineAt(_poly, i);\n      let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n      let poly2 = new Group(c.$add(axis.$multiply(r)), c.$subtract(axis.$multiply(r)));\n      let dist = Polygon._axisOverlap(_poly, poly2, axis);\n      if (dist > 0) {\n        return null;\n      } else if (Math.abs(dist) < minDist) {\n        let check = Rectangle.withinBound(edge, Line.perpendicularFromPt(edge, c)) || Circle.intersectLine2D(circle, edge).length > 0;\n        if (check) {\n          info.edge = edge;\n          info.normal = axis;\n          minDist = Math.abs(dist);\n          info.which = i;\n        }\n      }\n    }\n    if (!info.edge)\n      return null;\n    let dir = c.$subtract(Polygon.centroid(_poly)).dot(info.normal);\n    if (dir < 0)\n      info.normal.multiply(-1);\n    info.dist = minDist;\n    info.vertex = c;\n    return info;\n  }\n  static hasIntersectPolygon(poly1, poly2) {\n    let _poly1 = Util.iterToArray(poly1);\n    let _poly2 = Util.iterToArray(poly2);\n    let info = {\n      which: -1,\n      dist: 0,\n      normal: new Pt(),\n      edge: new Group(),\n      vertex: new Pt()\n    };\n    let minDist = Number.MAX_SAFE_INTEGER;\n    for (let i = 0, plen = _poly1.length + _poly2.length; i < plen; i++) {\n      let edge = i < _poly1.length ? Polygon.lineAt(_poly1, i) : Polygon.lineAt(_poly2, i - _poly1.length);\n      let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n      let dist = Polygon._axisOverlap(_poly1, _poly2, axis);\n      if (dist > 0) {\n        return null;\n      } else if (Math.abs(dist) < minDist) {\n        info.edge = edge;\n        info.normal = axis;\n        minDist = Math.abs(dist);\n        info.which = i < _poly1.length ? 0 : 1;\n      }\n    }\n    info.dist = minDist;\n    let b1 = info.which === 0 ? _poly2 : _poly1;\n    let b2 = info.which === 0 ? _poly1 : _poly2;\n    let c1 = Polygon.centroid(b1);\n    let c2 = Polygon.centroid(b2);\n    let dir = c1.$subtract(c2).dot(info.normal);\n    if (dir < 0)\n      info.normal.multiply(-1);\n    let smallest = Number.MAX_SAFE_INTEGER;\n    for (let i = 0, len = b1.length; i < len; i++) {\n      let d = info.normal.dot(b1[i].$subtract(c2));\n      if (d < smallest) {\n        smallest = d;\n        info.vertex = b1[i];\n      }\n    }\n    return info;\n  }\n  static intersectPolygon2D(poly1, poly2) {\n    let _poly1 = Util.iterToArray(poly1);\n    let _poly2 = Util.iterToArray(poly2);\n    let lp = Polygon.lines(_poly1);\n    let g = [];\n    for (let i = 0, len = lp.length; i < len; i++) {\n      let ins = Line.intersectPolygon2D(lp[i], _poly2, false);\n      if (ins)\n        g.push(ins);\n    }\n    return Util.flatten(g, true);\n  }\n  static toRects(polys) {\n    let boxes = [];\n    for (let g of polys) {\n      boxes.push(Geom.boundingBox(g));\n    }\n    let merged = Util.flatten(boxes, false);\n    boxes.unshift(Geom.boundingBox(merged));\n    return boxes;\n  }\n};\nvar Curve = class {\n  static getSteps(steps) {\n    let ts = new Group();\n    for (let i = 0; i <= steps; i++) {\n      let t = i / steps;\n      ts.push(new Pt(t * t * t, t * t, t, 1));\n    }\n    return ts;\n  }\n  static controlPoints(pts, index = 0, copyStart = false) {\n    let _pts = Util.iterToArray(pts);\n    if (index > _pts.length - 1)\n      return new Group();\n    let _index = (i) => i < _pts.length - 1 ? i : _pts.length - 1;\n    let p0 = _pts[index];\n    index = copyStart ? index : index + 1;\n    return new Group(\n      p0,\n      _pts[_index(index++)],\n      _pts[_index(index++)],\n      _pts[_index(index++)]\n    );\n  }\n  static _calcPt(ctrls, params) {\n    let x = ctrls.reduce((a, c, i) => a + c.x * params[i], 0);\n    let y = ctrls.reduce((a, c, i) => a + c.y * params[i], 0);\n    if (ctrls[0].length > 2) {\n      let z = ctrls.reduce((a, c, i) => a + c.z * params[i], 0);\n      return new Pt(x, y, z);\n    }\n    return new Pt(x, y);\n  }\n  static catmullRom(pts, steps = 10) {\n    let _pts = Util.iterToArray(pts);\n    if (_pts.length < 2)\n      return new Group();\n    let ps = new Group();\n    let ts = Curve.getSteps(steps);\n    let c = Curve.controlPoints(_pts, 0, true);\n    for (let i = 0; i <= steps; i++) {\n      ps.push(Curve.catmullRomStep(ts[i], c));\n    }\n    let k = 0;\n    while (k < _pts.length - 2) {\n      let cp = Curve.controlPoints(_pts, k);\n      if (cp.length > 0) {\n        for (let i = 0; i <= steps; i++) {\n          ps.push(Curve.catmullRomStep(ts[i], cp));\n        }\n        k++;\n      }\n    }\n    return ps;\n  }\n  static catmullRomStep(step, ctrls) {\n    let m = new Group(\n      new Pt(-0.5, 1, -0.5, 0),\n      new Pt(1.5, -2.5, 0, 1),\n      new Pt(-1.5, 2, 0.5, 0),\n      new Pt(0.5, -0.5, 0, 0)\n    );\n    return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n  }\n  static cardinal(pts, steps = 10, tension = 0.5) {\n    let _pts = Util.iterToArray(pts);\n    if (_pts.length < 2)\n      return new Group();\n    let ps = new Group();\n    let ts = Curve.getSteps(steps);\n    let c = Curve.controlPoints(_pts, 0, true);\n    for (let i = 0; i <= steps; i++) {\n      ps.push(Curve.cardinalStep(ts[i], c, tension));\n    }\n    let k = 0;\n    while (k < _pts.length - 2) {\n      let cp = Curve.controlPoints(_pts, k);\n      if (cp.length > 0) {\n        for (let i = 0; i <= steps; i++) {\n          ps.push(Curve.cardinalStep(ts[i], cp, tension));\n        }\n        k++;\n      }\n    }\n    return ps;\n  }\n  static cardinalStep(step, ctrls, tension = 0.5) {\n    let m = new Group(\n      new Pt(-1, 2, -1, 0),\n      new Pt(-1, 1, 0, 0),\n      new Pt(1, -2, 1, 0),\n      new Pt(1, -1, 0, 0)\n    );\n    let h = Mat.multiply([step], m, true)[0].multiply(tension);\n    let h2 = 2 * step[0] - 3 * step[1] + 1;\n    let h3 = -2 * step[0] + 3 * step[1];\n    let pt = Curve._calcPt(ctrls, h);\n    pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n    pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n    if (pt.length > 2)\n      pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n    return pt;\n  }\n  static bezier(pts, steps = 10) {\n    let _pts = Util.iterToArray(pts);\n    if (_pts.length < 4)\n      return new Group();\n    let ps = new Group();\n    let ts = Curve.getSteps(steps);\n    let k = 0;\n    while (k < _pts.length - 3) {\n      let c = Curve.controlPoints(_pts, k);\n      if (c.length > 0) {\n        for (let i = 0; i <= steps; i++) {\n          ps.push(Curve.bezierStep(ts[i], c));\n        }\n        k += 3;\n      }\n    }\n    return ps;\n  }\n  static bezierStep(step, ctrls) {\n    let m = new Group(\n      new Pt(-1, 3, -3, 1),\n      new Pt(3, -6, 3, 0),\n      new Pt(-3, 3, 0, 0),\n      new Pt(1, 0, 0, 0)\n    );\n    return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n  }\n  static bspline(pts, steps = 10, tension = 1) {\n    let _pts = Util.iterToArray(pts);\n    if (_pts.length < 2)\n      return new Group();\n    let ps = new Group();\n    let ts = Curve.getSteps(steps);\n    let k = 0;\n    while (k < _pts.length - 3) {\n      let c = Curve.controlPoints(_pts, k);\n      if (c.length > 0) {\n        if (tension !== 1) {\n          for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.bsplineTensionStep(ts[i], c, tension));\n          }\n        } else {\n          for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.bsplineStep(ts[i], c));\n          }\n        }\n        k++;\n      }\n    }\n    return ps;\n  }\n  static bsplineStep(step, ctrls) {\n    let m = new Group(\n      new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666),\n      new Pt(0.5, -1, 0, 0.6666666666666666),\n      new Pt(-0.5, 0.5, 0.5, 0.16666666666666666),\n      new Pt(0.16666666666666666, 0, 0, 0)\n    );\n    return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n  }\n  static bsplineTensionStep(step, ctrls, tension = 1) {\n    let m = new Group(\n      new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666),\n      new Pt(-1.5, 2, 0, -0.3333333333333333),\n      new Pt(1.5, -2.5, 0.5, 0.16666666666666666),\n      new Pt(0.16666666666666666, 0, 0, 0)\n    );\n    let h = Mat.multiply([step], m, true)[0].multiply(tension);\n    let h2 = 2 * step[0] - 3 * step[1] + 1;\n    let h3 = -2 * step[0] + 3 * step[1];\n    let pt = Curve._calcPt(ctrls, h);\n    pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n    pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n    if (pt.length > 2)\n      pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n    return pt;\n  }\n};\n\n// src/uheprng.ts\nfunction Mash() {\n  var n = 4022871197;\n  var mash = function(data) {\n    if (data) {\n      data = data.toString();\n      for (var i = 0; i < data.length; i++) {\n        n += data.charCodeAt(i);\n        var h = 0.02519603282416938 * n;\n        n = h >>> 0;\n        h -= n;\n        h *= n;\n        n = h >>> 0;\n        h -= n;\n        n += h * 4294967296;\n      }\n      return (n >>> 0) * 23283064365386963e-26;\n    } else\n      n = 4022871197;\n  };\n  return mash;\n}\nfunction uheprng_default(seed) {\n  var o = 48;\n  var c = 1;\n  var p = o;\n  var s = new Array(o);\n  var i, j, k = 0;\n  var mash = Mash();\n  for (i = 0; i < o; i++)\n    s[i] = mash(Math.random().toString());\n  function initState() {\n    mash();\n    for (i = 0; i < o; i++)\n      s[i] = mash(\" \");\n    c = 1;\n    p = o;\n  }\n  function cleanString(inStr) {\n    inStr = inStr.replace(/(^\\s*)|(\\s*$)/gi, \"\");\n    inStr = inStr.replace(/[\\x00-\\x1F]/gi, \"\");\n    inStr = inStr.replace(/\\n /, \"\\n\");\n    return inStr;\n  }\n  function hashString(inStr) {\n    inStr = cleanString(inStr);\n    mash(inStr);\n    for (i = 0; i < inStr.length; i++) {\n      k = inStr.charCodeAt(i);\n      for (j = 0; j < o; j++) {\n        s[j] -= mash(k.toString());\n        if (s[j] < 0)\n          s[j] += 1;\n      }\n    }\n  }\n  initState();\n  hashString(seed);\n  return {\n    random() {\n      if (++p >= o)\n        p = 0;\n      var t = 1768863 * s[p] + c * 23283064365386963e-26;\n      return s[p] = t - (c = t | 0);\n    }\n  };\n}\n\n// src/Num.ts\nvar Num = class {\n  static equals(a, b, threshold = 1e-5) {\n    return Math.abs(a - b) < threshold;\n  }\n  static lerp(a, b, t) {\n    return (1 - t) * a + t * b;\n  }\n  static clamp(val, min, max) {\n    return Math.max(min, Math.min(max, val));\n  }\n  static boundValue(val, min, max) {\n    let len = Math.abs(max - min);\n    let a = val % len;\n    if (a > max)\n      a -= len;\n    else if (a < min)\n      a += len;\n    return a;\n  }\n  static within(p, a, b) {\n    return p >= Math.min(a, b) && p <= Math.max(a, b);\n  }\n  static randomRange(a, b = 0) {\n    let r = a > b ? a - b : b - a;\n    return a + Num.random() * r;\n  }\n  static randomPt(a, b) {\n    let p = new Pt(a.length);\n    let range = b ? Vec.subtract(b, a) : a;\n    let start = b ? a : new Pt(a.length).fill(0);\n    for (let i = 0, len = p.length; i < len; i++) {\n      p[i] = Num.random() * range[i] + start[i];\n    }\n    return p;\n  }\n  static normalizeValue(n, a, b) {\n    let min = Math.min(a, b);\n    let max = Math.max(a, b);\n    return (n - min) / (max - min);\n  }\n  static sum(pts) {\n    let _pts = Util.iterToArray(pts);\n    let c = new Pt(_pts[0]);\n    for (let i = 1, len = _pts.length; i < len; i++) {\n      Vec.add(c, _pts[i]);\n    }\n    return c;\n  }\n  static average(pts) {\n    let _pts = Util.iterToArray(pts);\n    return Num.sum(_pts).divide(_pts.length);\n  }\n  static cycle(t, method = Shaping.sineInOut) {\n    return method(t > 0.5 ? 2 - t * 2 : t * 2);\n  }\n  static mapToRange(n, currA, currB, targetA, targetB) {\n    if (currA == currB)\n      throw new Error(\"[currMin, currMax] must define a range that is not zero\");\n    let min = Math.min(targetA, targetB);\n    let max = Math.max(targetA, targetB);\n    return Num.normalizeValue(n, currA, currB) * (max - min) + min;\n  }\n  static seed(seed) {\n    this.generator = uheprng_default(seed);\n  }\n  static random() {\n    return this.generator ? this.generator.random() : Math.random();\n  }\n};\nvar Geom = class {\n  static boundAngle(angle) {\n    return Num.boundValue(angle, 0, 360);\n  }\n  static boundRadian(radian) {\n    return Num.boundValue(radian, 0, Const.two_pi);\n  }\n  static toRadian(angle) {\n    return angle * Const.deg_to_rad;\n  }\n  static toDegree(radian) {\n    return radian * Const.rad_to_deg;\n  }\n  static boundingBox(pts) {\n    let minPt, maxPt;\n    for (let p of pts) {\n      if (minPt == void 0) {\n        minPt = p.clone();\n        maxPt = p.clone();\n      } else {\n        minPt = minPt.$min(p);\n        maxPt = maxPt.$max(p);\n      }\n    }\n    return new Group(minPt, maxPt);\n  }\n  static centroid(pts) {\n    return Num.average(pts);\n  }\n  static anchor(pts, ptOrIndex = 0, direction = \"to\") {\n    let method = direction == \"to\" ? \"subtract\" : \"add\";\n    let i = 0;\n    for (let p of pts) {\n      if (typeof ptOrIndex == \"number\") {\n        if (ptOrIndex !== i)\n          p[method](pts[ptOrIndex]);\n      } else {\n        p[method](ptOrIndex);\n      }\n      i++;\n    }\n  }\n  static interpolate(a, b, t = 0.5) {\n    let len = Math.min(a.length, b.length);\n    let d = Pt.make(len);\n    for (let i = 0; i < len; i++) {\n      d[i] = a[i] * (1 - t) + b[i] * t;\n    }\n    return d;\n  }\n  static perpendicular(pt, axis = Const.xy) {\n    let y = axis[1];\n    let x = axis[0];\n    let p = new Pt(pt);\n    let pa = new Pt(p);\n    pa[x] = -p[y];\n    pa[y] = p[x];\n    let pb = new Pt(p);\n    pb[x] = p[y];\n    pb[y] = -p[x];\n    return new Group(pa, pb);\n  }\n  static isPerpendicular(p1, p2) {\n    return new Pt(p1).dot(p2) === 0;\n  }\n  static withinBound(pt, boundPt1, boundPt2) {\n    for (let i = 0, len = Math.min(pt.length, boundPt1.length, boundPt2.length); i < len; i++) {\n      if (!Num.within(pt[i], boundPt1[i], boundPt2[i]))\n        return false;\n    }\n    return true;\n  }\n  static sortEdges(pts) {\n    let _pts = Util.iterToArray(pts);\n    let bounds = Geom.boundingBox(_pts);\n    let center = bounds[1].add(bounds[0]).divide(2);\n    let fn = (a, b) => {\n      if (a.length < 2 || b.length < 2)\n        throw new Error(\"Pt dimension cannot be less than 2\");\n      let da = a.$subtract(center);\n      let db = b.$subtract(center);\n      if (da[0] >= 0 && db[0] < 0)\n        return 1;\n      if (da[0] < 0 && db[0] >= 0)\n        return -1;\n      if (da[0] == 0 && db[0] == 0) {\n        if (da[1] >= 0 || db[1] >= 0)\n          return da[1] > db[1] ? 1 : -1;\n        return db[1] > da[1] ? 1 : -1;\n      }\n      let det = da.$cross2D(db);\n      if (det < 0)\n        return 1;\n      if (det > 0)\n        return -1;\n      return da[0] * da[0] + da[1] * da[1] > db[0] * db[0] + db[1] * db[1] ? 1 : -1;\n    };\n    return _pts.sort(fn);\n  }\n  static scale(ps, scale, anchor) {\n    let pts = Util.iterToArray(ps[0] !== void 0 && typeof ps[0] == \"number\" ? [ps] : ps);\n    let scs = typeof scale == \"number\" ? Pt.make(pts[0].length, scale) : scale;\n    if (!anchor)\n      anchor = Pt.make(pts[0].length, 0);\n    for (let i = 0, len = pts.length; i < len; i++) {\n      let p = pts[i];\n      for (let k = 0, lenP = p.length; k < lenP; k++) {\n        p[k] = anchor && anchor[k] ? anchor[k] + (p[k] - anchor[k]) * scs[k] : p[k] * scs[k];\n      }\n    }\n    return Geom;\n  }\n  static rotate2D(ps, angle, anchor, axis) {\n    let pts = Util.iterToArray(ps[0] !== void 0 && typeof ps[0] == \"number\" ? [ps] : ps);\n    let fn = anchor ? Mat.rotateAt2DMatrix : Mat.rotate2DMatrix;\n    if (!anchor)\n      anchor = Pt.make(pts[0].length, 0);\n    let cos = Math.cos(angle);\n    let sin = Math.sin(angle);\n    for (let i = 0, len = pts.length; i < len; i++) {\n      let p = axis ? pts[i].$take(axis) : pts[i];\n      p.to(Mat.transform2D(p, fn(cos, sin, anchor)));\n      if (axis) {\n        for (let k = 0; k < axis.length; k++) {\n          pts[i][axis[k]] = p[k];\n        }\n      }\n    }\n    return Geom;\n  }\n  static shear2D(ps, scale, anchor, axis) {\n    let pts = Util.iterToArray(ps[0] !== void 0 && typeof ps[0] == \"number\" ? [ps] : ps);\n    let s = typeof scale == \"number\" ? [scale, scale] : scale;\n    if (!anchor)\n      anchor = Pt.make(pts[0].length, 0);\n    let fn = anchor ? Mat.shearAt2DMatrix : Mat.shear2DMatrix;\n    let tanx = Math.tan(s[0]);\n    let tany = Math.tan(s[1]);\n    for (let i = 0, len = pts.length; i < len; i++) {\n      let p = axis ? pts[i].$take(axis) : pts[i];\n      p.to(Mat.transform2D(p, fn(tanx, tany, anchor)));\n      if (axis) {\n        for (let k = 0; k < axis.length; k++) {\n          pts[i][axis[k]] = p[k];\n        }\n      }\n    }\n    return Geom;\n  }\n  static reflect2D(ps, line, axis) {\n    let pts = Util.iterToArray(ps[0] !== void 0 && typeof ps[0] == \"number\" ? [ps] : ps);\n    let _line = Util.iterToArray(line);\n    let mat = Mat.reflectAt2DMatrix(_line[0], _line[1]);\n    for (let i = 0, len = pts.length; i < len; i++) {\n      let p = axis ? pts[i].$take(axis) : pts[i];\n      p.to(Mat.transform2D(p, mat));\n      if (axis) {\n        for (let k = 0; k < axis.length; k++) {\n          pts[i][axis[k]] = p[k];\n        }\n      }\n    }\n    return Geom;\n  }\n  static cosTable() {\n    let cos = new Float64Array(360);\n    for (let i = 0; i < 360; i++)\n      cos[i] = Math.cos(i * Math.PI / 180);\n    let find = (rad) => cos[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n    return { table: cos, cos: find };\n  }\n  static sinTable() {\n    let sin = new Float64Array(360);\n    for (let i = 0; i < 360; i++)\n      sin[i] = Math.sin(i * Math.PI / 180);\n    let find = (rad) => sin[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n    return { table: sin, sin: find };\n  }\n};\nvar Shaping = class {\n  static linear(t, c = 1) {\n    return c * t;\n  }\n  static quadraticIn(t, c = 1) {\n    return c * t * t;\n  }\n  static quadraticOut(t, c = 1) {\n    return -c * t * (t - 2);\n  }\n  static quadraticInOut(t, c = 1) {\n    let dt = t * 2;\n    return t < 0.5 ? c / 2 * t * t * 4 : -c / 2 * ((dt - 1) * (dt - 3) - 1);\n  }\n  static cubicIn(t, c = 1) {\n    return c * t * t * t;\n  }\n  static cubicOut(t, c = 1) {\n    let dt = t - 1;\n    return c * (dt * dt * dt + 1);\n  }\n  static cubicInOut(t, c = 1) {\n    let dt = t * 2;\n    return t < 0.5 ? c / 2 * dt * dt * dt : c / 2 * ((dt - 2) * (dt - 2) * (dt - 2) + 2);\n  }\n  static exponentialIn(t, c = 1, p = 0.25) {\n    return c * Math.pow(t, 1 / p);\n  }\n  static exponentialOut(t, c = 1, p = 0.25) {\n    return c * Math.pow(t, p);\n  }\n  static sineIn(t, c = 1) {\n    return -c * Math.cos(t * Const.half_pi) + c;\n  }\n  static sineOut(t, c = 1) {\n    return c * Math.sin(t * Const.half_pi);\n  }\n  static sineInOut(t, c = 1) {\n    return -c / 2 * (Math.cos(Math.PI * t) - 1);\n  }\n  static cosineApprox(t, c = 1) {\n    let t2 = t * t;\n    let t4 = t2 * t2;\n    let t6 = t4 * t2;\n    return c * (4 * t6 / 9 - 17 * t4 / 9 + 22 * t2 / 9);\n  }\n  static circularIn(t, c = 1) {\n    return -c * (Math.sqrt(1 - t * t) - 1);\n  }\n  static circularOut(t, c = 1) {\n    let dt = t - 1;\n    return c * Math.sqrt(1 - dt * dt);\n  }\n  static circularInOut(t, c = 1) {\n    let dt = t * 2;\n    return t < 0.5 ? -c / 2 * (Math.sqrt(1 - dt * dt) - 1) : c / 2 * (Math.sqrt(1 - (dt - 2) * (dt - 2)) + 1);\n  }\n  static elasticIn(t, c = 1, p = 0.7) {\n    let dt = t - 1;\n    let s = p / Const.two_pi * 1.5707963267948966;\n    return c * (-Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p));\n  }\n  static elasticOut(t, c = 1, p = 0.7) {\n    let s = p / Const.two_pi * 1.5707963267948966;\n    return c * (Math.pow(2, -10 * t) * Math.sin((t - s) * Const.two_pi / p)) + c;\n  }\n  static elasticInOut(t, c = 1, p = 0.6) {\n    let dt = t * 2;\n    let s = p / Const.two_pi * 1.5707963267948966;\n    if (t < 0.5) {\n      dt -= 1;\n      return c * (-0.5 * (Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p)));\n    } else {\n      dt -= 1;\n      return c * (0.5 * (Math.pow(2, -10 * dt) * Math.sin((dt - s) * Const.two_pi / p))) + c;\n    }\n  }\n  static bounceIn(t, c = 1) {\n    return c - Shaping.bounceOut(1 - t, c);\n  }\n  static bounceOut(t, c = 1) {\n    if (t < 1 / 2.75) {\n      return c * (7.5625 * t * t);\n    } else if (t < 2 / 2.75) {\n      t -= 1.5 / 2.75;\n      return c * (7.5625 * t * t + 0.75);\n    } else if (t < 2.5 / 2.75) {\n      t -= 2.25 / 2.75;\n      return c * (7.5625 * t * t + 0.9375);\n    } else {\n      t -= 2.625 / 2.75;\n      return c * (7.5625 * t * t + 0.984375);\n    }\n  }\n  static bounceInOut(t, c = 1) {\n    return t < 0.5 ? Shaping.bounceIn(t * 2, c) / 2 : Shaping.bounceOut(t * 2 - 1, c) / 2 + c / 2;\n  }\n  static sigmoid(t, c = 1, p = 10) {\n    let d = p * (t - 0.5);\n    return c / (1 + Math.exp(-d));\n  }\n  static logSigmoid(t, c = 1, p = 0.7) {\n    p = Math.max(Const.epsilon, Math.min(1 - Const.epsilon, p));\n    p = 1 / (1 - p);\n    let A = 1 / (1 + Math.exp((t - 0.5) * p * -2));\n    let B = 1 / (1 + Math.exp(p));\n    let C = 1 / (1 + Math.exp(-p));\n    return c * (A - B) / (C - B);\n  }\n  static seat(t, c = 1, p = 0.5) {\n    if (t < 0.5) {\n      return c * Math.pow(2 * t, 1 - p) / 2;\n    } else {\n      return c * (1 - Math.pow(2 * (1 - t), 1 - p) / 2);\n    }\n  }\n  static quadraticBezier(t, c = 1, p = [0.05, 0.95]) {\n    let a = typeof p != \"number\" ? p[0] : p;\n    let b = typeof p != \"number\" ? p[1] : 0.5;\n    let om2a = 1 - 2 * a;\n    if (om2a === 0) {\n      om2a = Const.epsilon;\n    }\n    let d = (Math.sqrt(a * a + om2a * t) - a) / om2a;\n    return c * ((1 - 2 * b) * (d * d) + 2 * b * d);\n  }\n  static cubicBezier(t, c = 1, p1 = [0.1, 0.7], p2 = [0.9, 0.2]) {\n    let curve = new Group(new Pt(0, 0), new Pt(p1), new Pt(p2), new Pt(1, 1));\n    return c * Curve.bezierStep(new Pt(t * t * t, t * t, t, 1), Curve.controlPoints(curve)).y;\n  }\n  static quadraticTarget(t, c = 1, p1 = [0.2, 0.35]) {\n    let a = Math.min(1 - Const.epsilon, Math.max(Const.epsilon, p1[0]));\n    let b = Math.min(1, Math.max(0, p1[1]));\n    let A = (1 - b) / (1 - a) - b / a;\n    let B = (A * (a * a) - b) / a;\n    let y = A * (t * t) - B * t;\n    return c * Math.min(1, Math.max(0, y));\n  }\n  static cliff(t, c = 1, p = 0.5) {\n    return t > p ? c : 0;\n  }\n  static step(fn, steps, t, c, ...args) {\n    let s = 1 / steps;\n    let tt = Math.floor(t / s) * s;\n    return fn(tt, c, ...args);\n  }\n};\nvar Range = class {\n  constructor(g) {\n    this._dims = 0;\n    this._source = Group.fromPtArray(g);\n    this.calc();\n  }\n  get max() {\n    return this._max.clone();\n  }\n  get min() {\n    return this._min.clone();\n  }\n  get magnitude() {\n    return this._mag.clone();\n  }\n  calc() {\n    if (!this._source)\n      return;\n    let dims = this._source[0].length;\n    this._dims = dims;\n    let max = new Pt(dims);\n    let min = new Pt(dims);\n    let mag = new Pt(dims);\n    for (let i = 0; i < dims; i++) {\n      max[i] = Const.min;\n      min[i] = Const.max;\n      mag[i] = 0;\n      let s = this._source.zipSlice(i);\n      for (let k = 0, len = s.length; k < len; k++) {\n        max[i] = Math.max(max[i], s[k]);\n        min[i] = Math.min(min[i], s[k]);\n        mag[i] = max[i] - min[i];\n      }\n    }\n    this._max = max;\n    this._min = min;\n    this._mag = mag;\n    return this;\n  }\n  mapTo(min, max, exclude) {\n    let target = new Group();\n    for (let i = 0, len = this._source.length; i < len; i++) {\n      let g = this._source[i];\n      let n = new Pt(this._dims);\n      for (let k = 0; k < this._dims; k++) {\n        n[k] = exclude && exclude[k] ? g[k] : Num.mapToRange(g[k], this._min[k], this._max[k], min, max);\n      }\n      target.push(n);\n    }\n    return target;\n  }\n  append(pts, update = true) {\n    let _pts = Util.iterToArray(pts);\n    if (_pts[0].length !== this._dims)\n      throw new Error(`Dimensions don't match. ${this._dims} dimensions in Range and ${_pts[0].length} provided in parameter. `);\n    this._source = this._source.concat(_pts);\n    if (update)\n      this.calc();\n    return this;\n  }\n  ticks(count) {\n    let g = new Group();\n    for (let i = 0; i <= count; i++) {\n      let p = new Pt(this._dims);\n      for (let k = 0, len = this._max.length; k < len; k++) {\n        p[k] = Num.lerp(this._min[k], this._max[k], i / count);\n      }\n      g.push(p);\n    }\n    return g;\n  }\n};\n\n// src/Util.ts\nvar Const = {\n  xy: \"xy\",\n  yz: \"yz\",\n  xz: \"xz\",\n  xyz: \"xyz\",\n  horizontal: 0,\n  vertical: 1,\n  identical: 0,\n  right: 4,\n  bottom_right: 5,\n  bottom: 6,\n  bottom_left: 7,\n  left: 8,\n  top_left: 1,\n  top: 2,\n  top_right: 3,\n  epsilon: 1e-4,\n  max: Number.MAX_VALUE,\n  min: Number.MIN_VALUE,\n  pi: Math.PI,\n  two_pi: 6.283185307179586,\n  half_pi: 1.5707963267948966,\n  quarter_pi: 0.7853981633974483,\n  one_degree: 0.017453292519943295,\n  rad_to_deg: 57.29577951308232,\n  deg_to_rad: 0.017453292519943295,\n  gravity: 9.81,\n  newton: 0.10197,\n  gaussian: 0.3989422804014327\n};\nvar _Util = class {\n  static warnLevel(lv) {\n    if (lv) {\n      _Util._warnLevel = lv;\n    }\n    return _Util._warnLevel;\n  }\n  static getArgs(args) {\n    if (args.length < 1)\n      return [];\n    let pos = [];\n    let isArray = Array.isArray(args[0]) || ArrayBuffer.isView(args[0]);\n    if (typeof args[0] === \"number\") {\n      pos = Array.prototype.slice.call(args);\n    } else if (typeof args[0] === \"object\" && !isArray) {\n      let a = [\"x\", \"y\", \"z\", \"w\"];\n      let p = args[0];\n      for (let i = 0; i < a.length; i++) {\n        if (p.length && i >= p.length || !(a[i] in p))\n          break;\n        pos.push(p[a[i]]);\n      }\n    } else if (isArray) {\n      pos = [].slice.call(args[0]);\n    }\n    return pos;\n  }\n  static warn(message = \"error\", defaultReturn = void 0) {\n    if (_Util.warnLevel() == \"error\") {\n      throw new Error(message);\n    } else if (_Util.warnLevel() == \"warn\") {\n      console.warn(message);\n    }\n    return defaultReturn;\n  }\n  static randomInt(range, start = 0) {\n    _Util.warn(\"Util.randomInt is deprecated. Please use `Num.randomRange`\");\n    return Math.floor(Num.random() * range) + start;\n  }\n  static split(pts, size, stride, loopBack = false, matchSize = true) {\n    let chunks = [];\n    let part = [];\n    let st = stride || size;\n    let index = 0;\n    if (pts.length <= 0 || st <= 0)\n      return [];\n    while (index < pts.length) {\n      part = [];\n      for (let k = 0; k < size; k++) {\n        if (loopBack) {\n          part.push(pts[(index + k) % pts.length]);\n        } else {\n          if (index + k >= pts.length)\n            break;\n          part.push(pts[index + k]);\n        }\n      }\n      index += st;\n      if (!matchSize || matchSize && part.length === size)\n        chunks.push(part);\n    }\n    return chunks;\n  }\n  static flatten(pts, flattenAsGroup = true) {\n    let arr = flattenAsGroup ? new Group() : new Array();\n    return arr.concat.apply(arr, pts);\n  }\n  static combine(a, b, op) {\n    let result = [];\n    for (let i = 0, len = a.length; i < len; i++) {\n      for (let k = 0, lenB = b.length; k < lenB; k++) {\n        result.push(op(a[i], b[k]));\n      }\n    }\n    return result;\n  }\n  static zip(arrays) {\n    let z = [];\n    for (let i = 0, len = arrays[0].length; i < len; i++) {\n      let p = [];\n      for (let k = 0; k < arrays.length; k++) {\n        p.push(arrays[k][i]);\n      }\n      z.push(p);\n    }\n    return z;\n  }\n  static stepper(max, min = 0, stride = 1, callback) {\n    let c = min;\n    return function() {\n      c += stride;\n      if (c >= max) {\n        c = min + (c - max);\n      }\n      if (callback)\n        callback(c);\n      return c;\n    };\n  }\n  static forRange(fn, range, start = 0, step = 1) {\n    let temp = [];\n    for (let i = start, len = range; i < len; i += step) {\n      temp[i] = fn(i);\n    }\n    return temp;\n  }\n  static load(url, callback) {\n    var request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n    request.onload = function() {\n      if (request.status >= 200 && request.status < 400) {\n        callback(request.responseText, true);\n      } else {\n        callback(`Server error (${request.status}) when loading \"${url}\"`, false);\n      }\n    };\n    request.onerror = function() {\n      callback(`Unknown network error`, false);\n    };\n    request.send();\n  }\n  static download(space, filename = \"pts_canvas_image\", filetype = \"png\", quality = 1) {\n    const ftype = filetype === \"jpg\" ? \"jpeg\" : filetype;\n    space.element.toBlob(function(blob) {\n      const link = document.createElement(\"a\");\n      const url = URL.createObjectURL(blob);\n      link.href = url;\n      link.download = `${filename}.${filetype}`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n    }, `image/${ftype}`, quality);\n  }\n  static performance(avgFrames = 10) {\n    let last = Date.now();\n    let avg = [];\n    return function() {\n      const now = Date.now();\n      avg.push(now - last);\n      if (avg.length >= avgFrames)\n        avg.shift();\n      last = now;\n      return Math.floor(avg.reduce((a, b) => a + b, 0) / avg.length);\n    };\n  }\n  static arrayCheck(pts, minRequired = 2) {\n    if (Array.isArray(pts) && pts.length < minRequired) {\n      _Util.warn(`Requires ${minRequired} or more Pts in this Group.`);\n      return false;\n    }\n    return true;\n  }\n  static iterToArray(it) {\n    return !Array.isArray(it) ? [...it] : it;\n  }\n  static isMobile() {\n    return /iPhone|iPad|Android/i.test(navigator.userAgent);\n  }\n};\nvar Util = _Util;\nUtil._warnLevel = \"mute\";\n\n// src/Pt.ts\nvar Pt = class extends Float32Array {\n  constructor(...args) {\n    var __super = (...args) => {\n      super(...args);\n    };\n    if (args.length === 1 && typeof args[0] == \"number\") {\n      __super(args[0]);\n    } else {\n      __super(args.length > 0 ? Util.getArgs(args) : [0, 0]);\n    }\n  }\n  static make(dimensions, defaultValue = 0, randomize = false) {\n    let p = new Float32Array(dimensions);\n    if (defaultValue)\n      p.fill(defaultValue);\n    if (randomize) {\n      for (let i = 0, len = p.length; i < len; i++) {\n        p[i] = p[i] * Num.random();\n      }\n    }\n    return new Pt(p);\n  }\n  get id() {\n    return this._id;\n  }\n  set id(s) {\n    this._id = s;\n  }\n  get x() {\n    return this[0];\n  }\n  set x(n) {\n    this[0] = n;\n  }\n  get y() {\n    return this[1];\n  }\n  set y(n) {\n    this[1] = n;\n  }\n  get z() {\n    return this[2];\n  }\n  set z(n) {\n    this[2] = n;\n  }\n  get w() {\n    return this[3];\n  }\n  set w(n) {\n    this[3] = n;\n  }\n  clone() {\n    return new Pt(this);\n  }\n  equals(p, threshold = 1e-6) {\n    for (let i = 0, len = this.length; i < len; i++) {\n      if (Math.abs(this[i] - p[i]) > threshold)\n        return false;\n    }\n    return true;\n  }\n  to(...args) {\n    let p = Util.getArgs(args);\n    for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n      this[i] = p[i];\n    }\n    return this;\n  }\n  $to(...args) {\n    return this.clone().to(...args);\n  }\n  toAngle(radian, magnitude, anchorFromPt = false) {\n    let m = magnitude != void 0 ? magnitude : this.magnitude();\n    let change = [Math.cos(radian) * m, Math.sin(radian) * m];\n    return anchorFromPt ? this.add(change) : this.to(change);\n  }\n  op(fn) {\n    let self = this;\n    return (...params) => {\n      return fn(self, ...params);\n    };\n  }\n  ops(fns) {\n    let _ops = [];\n    for (let i = 0, len = fns.length; i < len; i++) {\n      _ops.push(this.op(fns[i]));\n    }\n    return _ops;\n  }\n  $take(axis) {\n    let p = [];\n    for (let i = 0, len = axis.length; i < len; i++) {\n      p.push(this[axis[i]] || 0);\n    }\n    return new Pt(p);\n  }\n  $concat(...args) {\n    return new Pt(this.toArray().concat(Util.getArgs(args)));\n  }\n  add(...args) {\n    args.length === 1 && typeof args[0] == \"number\" ? Vec.add(this, args[0]) : Vec.add(this, Util.getArgs(args));\n    return this;\n  }\n  $add(...args) {\n    return this.clone().add(...args);\n  }\n  subtract(...args) {\n    args.length === 1 && typeof args[0] == \"number\" ? Vec.subtract(this, args[0]) : Vec.subtract(this, Util.getArgs(args));\n    return this;\n  }\n  $subtract(...args) {\n    return this.clone().subtract(...args);\n  }\n  multiply(...args) {\n    args.length === 1 && typeof args[0] == \"number\" ? Vec.multiply(this, args[0]) : Vec.multiply(this, Util.getArgs(args));\n    return this;\n  }\n  $multiply(...args) {\n    return this.clone().multiply(...args);\n  }\n  divide(...args) {\n    args.length === 1 && typeof args[0] == \"number\" ? Vec.divide(this, args[0]) : Vec.divide(this, Util.getArgs(args));\n    return this;\n  }\n  $divide(...args) {\n    return this.clone().divide(...args);\n  }\n  magnitudeSq() {\n    return Vec.dot(this, this);\n  }\n  magnitude() {\n    return Vec.magnitude(this);\n  }\n  unit(magnitude = void 0) {\n    Vec.unit(this, magnitude);\n    return this;\n  }\n  $unit(magnitude = void 0) {\n    return this.clone().unit(magnitude);\n  }\n  dot(...args) {\n    return Vec.dot(this, Util.getArgs(args));\n  }\n  $cross2D(...args) {\n    return Vec.cross2D(this, Util.getArgs(args));\n  }\n  $cross(...args) {\n    return Vec.cross(this, Util.getArgs(args));\n  }\n  $project(...args) {\n    return this.$multiply(this.dot(...args) / this.magnitudeSq());\n  }\n  projectScalar(...args) {\n    return this.dot(...args) / this.magnitude();\n  }\n  abs() {\n    Vec.abs(this);\n    return this;\n  }\n  $abs() {\n    return this.clone().abs();\n  }\n  floor() {\n    Vec.floor(this);\n    return this;\n  }\n  $floor() {\n    return this.clone().floor();\n  }\n  ceil() {\n    Vec.ceil(this);\n    return this;\n  }\n  $ceil() {\n    return this.clone().ceil();\n  }\n  round() {\n    Vec.round(this);\n    return this;\n  }\n  $round() {\n    return this.clone().round();\n  }\n  minValue() {\n    return Vec.min(this);\n  }\n  maxValue() {\n    return Vec.max(this);\n  }\n  $min(...args) {\n    let p = Util.getArgs(args);\n    let m = this.clone();\n    for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n      m[i] = Math.min(this[i], p[i]);\n    }\n    return m;\n  }\n  $max(...args) {\n    let p = Util.getArgs(args);\n    let m = this.clone();\n    for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n      m[i] = Math.max(this[i], p[i]);\n    }\n    return m;\n  }\n  angle(axis = Const.xy) {\n    return Math.atan2(this[axis[1]], this[axis[0]]);\n  }\n  angleBetween(p, axis = Const.xy) {\n    return Geom.boundRadian(this.angle(axis)) - Geom.boundRadian(p.angle(axis));\n  }\n  scale(scale, anchor) {\n    Geom.scale(this, scale, anchor || Pt.make(this.length, 0));\n    return this;\n  }\n  rotate2D(angle, anchor, axis) {\n    Geom.rotate2D(this, angle, anchor || Pt.make(this.length, 0), axis);\n    return this;\n  }\n  shear2D(scale, anchor, axis) {\n    Geom.shear2D(this, scale, anchor || Pt.make(this.length, 0), axis);\n    return this;\n  }\n  reflect2D(line, axis) {\n    Geom.reflect2D(this, line, axis);\n    return this;\n  }\n  toString() {\n    return `Pt(${this.join(\", \")})`;\n  }\n  toArray() {\n    return [].slice.call(this);\n  }\n  toGroup() {\n    return new Group(Pt.make(this.length), this.clone());\n  }\n  toBound() {\n    return new Bound(Pt.make(this.length), this.clone());\n  }\n};\nvar Group = class extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n  get id() {\n    return this._id;\n  }\n  set id(s) {\n    this._id = s;\n  }\n  get p1() {\n    return this[0];\n  }\n  get p2() {\n    return this[1];\n  }\n  get p3() {\n    return this[2];\n  }\n  get p4() {\n    return this[3];\n  }\n  get q1() {\n    return this[this.length - 1];\n  }\n  get q2() {\n    return this[this.length - 2];\n  }\n  get q3() {\n    return this[this.length - 3];\n  }\n  get q4() {\n    return this[this.length - 4];\n  }\n  clone() {\n    let group = new Group();\n    for (let i = 0, len = this.length; i < len; i++) {\n      group.push(this[i].clone());\n    }\n    return group;\n  }\n  static fromArray(list) {\n    let g = new Group();\n    for (let li of list) {\n      let p = li instanceof Pt ? li : new Pt(li);\n      g.push(p);\n    }\n    return g;\n  }\n  static fromPtArray(list) {\n    return Group.from(list);\n  }\n  split(chunkSize, stride, loopBack = false) {\n    let sp = Util.split(this, chunkSize, stride, loopBack);\n    return sp;\n  }\n  insert(pts, index = 0) {\n    Group.prototype.splice.apply(this, [index, 0, ...pts]);\n    return this;\n  }\n  remove(index = 0, count = 1) {\n    let param = index < 0 ? [index * -1 - 1, count] : [index, count];\n    return Group.prototype.splice.apply(this, param);\n  }\n  segments(pts_per_segment = 2, stride = 1, loopBack = false) {\n    return this.split(pts_per_segment, stride, loopBack);\n  }\n  lines() {\n    return this.segments(2, 1);\n  }\n  centroid() {\n    return Geom.centroid(this);\n  }\n  boundingBox() {\n    return Geom.boundingBox(this);\n  }\n  anchorTo(ptOrIndex = 0) {\n    Geom.anchor(this, ptOrIndex, \"to\");\n  }\n  anchorFrom(ptOrIndex = 0) {\n    Geom.anchor(this, ptOrIndex, \"from\");\n  }\n  op(fn) {\n    let self = this;\n    return (...params) => {\n      return fn(self, ...params);\n    };\n  }\n  ops(fns) {\n    let _ops = [];\n    for (let i = 0, len = fns.length; i < len; i++) {\n      _ops.push(this.op(fns[i]));\n    }\n    return _ops;\n  }\n  interpolate(t) {\n    t = Num.clamp(t, 0, 1);\n    let chunk = this.length - 1;\n    let tc = 1 / (this.length - 1);\n    let idx = Math.floor(t / tc);\n    return Geom.interpolate(this[idx], this[Math.min(this.length - 1, idx + 1)], (t - idx * tc) * chunk);\n  }\n  moveBy(...args) {\n    return this.add(...args);\n  }\n  moveTo(...args) {\n    let d = new Pt(Util.getArgs(args)).subtract(this[0]);\n    this.moveBy(d);\n    return this;\n  }\n  scale(scale, anchor) {\n    for (let i = 0, len = this.length; i < len; i++) {\n      Geom.scale(this[i], scale, anchor || this[0]);\n    }\n    return this;\n  }\n  rotate2D(angle, anchor, axis) {\n    for (let i = 0, len = this.length; i < len; i++) {\n      Geom.rotate2D(this[i], angle, anchor || this[0], axis);\n    }\n    return this;\n  }\n  shear2D(scale, anchor, axis) {\n    for (let i = 0, len = this.length; i < len; i++) {\n      Geom.shear2D(this[i], scale, anchor || this[0], axis);\n    }\n    return this;\n  }\n  reflect2D(line, axis) {\n    for (let i = 0, len = this.length; i < len; i++) {\n      Geom.reflect2D(this[i], line, axis);\n    }\n    return this;\n  }\n  sortByDimension(dim, desc = false) {\n    return this.sort((a, b) => desc ? b[dim] - a[dim] : a[dim] - b[dim]);\n  }\n  forEachPt(ptFn, ...args) {\n    if (!this[0][ptFn]) {\n      Util.warn(`${ptFn} is not a function of Pt`);\n      return this;\n    }\n    for (let i = 0, len = this.length; i < len; i++) {\n      this[i] = this[i][ptFn](...args);\n    }\n    return this;\n  }\n  add(...args) {\n    return this.forEachPt(\"add\", ...args);\n  }\n  subtract(...args) {\n    return this.forEachPt(\"subtract\", ...args);\n  }\n  multiply(...args) {\n    return this.forEachPt(\"multiply\", ...args);\n  }\n  divide(...args) {\n    return this.forEachPt(\"divide\", ...args);\n  }\n  $matrixAdd(g) {\n    return Mat.add(this, g);\n  }\n  $matrixMultiply(g, transposed = false, elementwise = false) {\n    return Mat.multiply(this, g, transposed, elementwise);\n  }\n  zipSlice(index, defaultValue = false) {\n    return Mat.zipSlice(this, index, defaultValue);\n  }\n  $zip(defaultValue = void 0, useLongest = false) {\n    return Mat.zip(this, defaultValue, useLongest);\n  }\n  toBound() {\n    return Bound.fromGroup(this);\n  }\n  toString() {\n    return \"Group[ \" + this.reduce((p, c) => p + c.toString() + \" \", \"\") + \" ]\";\n  }\n};\nvar Bound = class extends Group {\n  constructor(...args) {\n    super(...args);\n    this._center = new Pt();\n    this._size = new Pt();\n    this._topLeft = new Pt();\n    this._bottomRight = new Pt();\n    this._inited = false;\n    this.init();\n  }\n  static fromBoundingRect(rect) {\n    let b = new Bound(new Pt(rect.left || 0, rect.top || 0), new Pt(rect.right || 0, rect.bottom || 0));\n    if (rect.width && rect.height)\n      b.size = new Pt(rect.width, rect.height);\n    return b;\n  }\n  static fromGroup(g) {\n    let _g = Util.iterToArray(g);\n    if (_g.length < 2)\n      throw new Error(\"Cannot create a Bound from a group that has less than 2 Pt\");\n    return new Bound(_g[0], _g[_g.length - 1]);\n  }\n  init() {\n    if (this.p1) {\n      this._size = this.p1.clone();\n      this._inited = true;\n    }\n    if (this.p1 && this.p2) {\n      let a = this.p1;\n      let b = this.p2;\n      this.topLeft = a.$min(b);\n      this._bottomRight = a.$max(b);\n      this._updateSize();\n      this._inited = true;\n    }\n  }\n  clone() {\n    return new Bound(this._topLeft.clone(), this._bottomRight.clone());\n  }\n  _updateSize() {\n    this._size = this._bottomRight.$subtract(this._topLeft).abs();\n    this._updateCenter();\n  }\n  _updateCenter() {\n    this._center = this._size.$multiply(0.5).add(this._topLeft);\n  }\n  _updatePosFromTop() {\n    this._bottomRight = this._topLeft.$add(this._size);\n    this._updateCenter();\n  }\n  _updatePosFromBottom() {\n    this._topLeft = this._bottomRight.$subtract(this._size);\n    this._updateCenter();\n  }\n  _updatePosFromCenter() {\n    let half = this._size.$multiply(0.5);\n    this._topLeft = this._center.$subtract(half);\n    this._bottomRight = this._center.$add(half);\n  }\n  get size() {\n    return new Pt(this._size);\n  }\n  set size(p) {\n    this._size = new Pt(p);\n    this._updatePosFromTop();\n  }\n  get center() {\n    return new Pt(this._center);\n  }\n  set center(p) {\n    this._center = new Pt(p);\n    this._updatePosFromCenter();\n  }\n  get topLeft() {\n    return new Pt(this._topLeft);\n  }\n  set topLeft(p) {\n    this._topLeft = new Pt(p);\n    this[0] = this._topLeft;\n    this._updateSize();\n  }\n  get bottomRight() {\n    return new Pt(this._bottomRight);\n  }\n  set bottomRight(p) {\n    this._bottomRight = new Pt(p);\n    this[1] = this._bottomRight;\n    this._updateSize();\n  }\n  get width() {\n    return this._size.length > 0 ? this._size.x : 0;\n  }\n  set width(w) {\n    this._size.x = w;\n    this._updatePosFromTop();\n  }\n  get height() {\n    return this._size.length > 1 ? this._size.y : 0;\n  }\n  set height(h) {\n    this._size.y = h;\n    this._updatePosFromTop();\n  }\n  get depth() {\n    return this._size.length > 2 ? this._size.z : 0;\n  }\n  set depth(d) {\n    this._size.z = d;\n    this._updatePosFromTop();\n  }\n  get x() {\n    return this.topLeft.x;\n  }\n  get y() {\n    return this.topLeft.y;\n  }\n  get z() {\n    return this.topLeft.z;\n  }\n  get inited() {\n    return this._inited;\n  }\n  update() {\n    this._topLeft = this[0];\n    this._bottomRight = this[1];\n    this._updateSize();\n    return this;\n  }\n};\n\n// src/UI.ts\nvar UIShape = {\n  rectangle: \"rectangle\",\n  circle: \"circle\",\n  polygon: \"polygon\",\n  polyline: \"polyline\",\n  line: \"line\"\n};\nvar UIPointerActions = {\n  up: \"up\",\n  down: \"down\",\n  move: \"move\",\n  drag: \"drag\",\n  uidrag: \"uidrag\",\n  drop: \"drop\",\n  uidrop: \"uidrop\",\n  over: \"over\",\n  out: \"out\",\n  enter: \"enter\",\n  leave: \"leave\",\n  click: \"click\",\n  keydown: \"keydown\",\n  keyup: \"keyup\",\n  contextmenu: \"contextmenu\",\n  all: \"all\"\n};\nvar _UI = class {\n  constructor(group, shape, states = {}, id) {\n    this._holds = /* @__PURE__ */ new Map();\n    this._group = Group.fromArray(group);\n    this._shape = shape;\n    this._id = id === void 0 ? `ui_${_UI._counter++}` : id;\n    this._states = states;\n    this._actions = {};\n  }\n  static fromRectangle(group, states, id) {\n    return new this(group, UIShape.rectangle, states, id);\n  }\n  static fromCircle(group, states, id) {\n    return new this(group, UIShape.circle, states, id);\n  }\n  static fromPolygon(group, states, id) {\n    return new this(group, UIShape.polygon, states, id);\n  }\n  static fromUI(ui, states, id) {\n    return new this(ui.group, ui.shape, states || ui._states, id);\n  }\n  get id() {\n    return this._id;\n  }\n  set id(d) {\n    this._id = d;\n  }\n  get group() {\n    return this._group;\n  }\n  set group(d) {\n    this._group = d;\n  }\n  get shape() {\n    return this._shape;\n  }\n  set shape(d) {\n    this._shape = d;\n  }\n  state(key, value) {\n    if (!key)\n      return null;\n    if (value !== void 0) {\n      this._states[key] = value;\n      return this;\n    }\n    return this._states[key];\n  }\n  on(type, fn) {\n    if (!this._actions[type])\n      this._actions[type] = [];\n    return _UI._addHandler(this._actions[type], fn);\n  }\n  off(type, which) {\n    if (!this._actions[type])\n      return false;\n    if (which === void 0) {\n      delete this._actions[type];\n      return true;\n    } else {\n      return _UI._removeHandler(this._actions[type], which);\n    }\n  }\n  listen(type, p, evt) {\n    if (this._actions[type] !== void 0) {\n      if (this._within(p) || Array.from(this._holds.values()).indexOf(type) >= 0) {\n        _UI._trigger(this._actions[type], this, p, type, evt);\n        return true;\n      } else if (this._actions[\"all\"]) {\n        _UI._trigger(this._actions[\"all\"], this, p, type, evt);\n        return true;\n      }\n    }\n    return false;\n  }\n  hold(type) {\n    let newKey = Math.max(0, ...Array.from(this._holds.keys())) + 1;\n    this._holds.set(newKey, type);\n    return newKey;\n  }\n  unhold(key) {\n    if (key !== void 0) {\n      this._holds.delete(key);\n    } else {\n      this._holds.clear();\n    }\n  }\n  static track(uis, type, p, evt) {\n    for (let i = 0, len = uis.length; i < len; i++) {\n      uis[i].listen(type, p, evt);\n    }\n  }\n  render(fn) {\n    fn(this._group, this._states);\n  }\n  toString() {\n    return `UI ${this.group.toString}`;\n  }\n  _within(p) {\n    let fn = null;\n    if (this._shape === UIShape.rectangle) {\n      fn = Rectangle.withinBound;\n    } else if (this._shape === UIShape.circle) {\n      fn = Circle.withinBound;\n    } else if (this._shape === UIShape.polygon) {\n      fn = Polygon.hasIntersectPoint;\n    } else {\n      return false;\n    }\n    return fn(this._group, p);\n  }\n  static _trigger(fns, target, pt, type, evt) {\n    if (fns) {\n      for (let i = 0, len = fns.length; i < len; i++) {\n        if (fns[i])\n          fns[i](target, pt, type, evt);\n      }\n    }\n  }\n  static _addHandler(fns, fn) {\n    if (fn) {\n      fns.push(fn);\n      return fns.length - 1;\n    } else {\n      return -1;\n    }\n  }\n  static _removeHandler(fns, index) {\n    if (index >= 0 && index < fns.length) {\n      let temp = fns.length;\n      fns.splice(index, 1);\n      return temp > fns.length;\n    } else {\n      return false;\n    }\n  }\n};\nvar UI = _UI;\nUI._counter = 0;\nvar UIButton = class extends UI {\n  constructor(group, shape, states = {}, id) {\n    super(group, shape, states, id);\n    this._hoverID = -1;\n    if (states.hover === void 0)\n      this._states[\"hover\"] = false;\n    if (states.clicks === void 0)\n      this._states[\"clicks\"] = 0;\n    const UA = UIPointerActions;\n    this.on(UA.up, (target, pt, type, evt) => {\n      this.state(\"clicks\", this._states.clicks + 1);\n    });\n    this.on(UA.move, (target, pt, type, evt) => {\n      let hover = this._within(pt);\n      if (hover && !this._states.hover) {\n        this.state(\"hover\", true);\n        UI._trigger(this._actions[UA.enter], this, pt, UA.enter, evt);\n        var _capID = this.hold(UA.move);\n        this._hoverID = this.on(UA.move, (t, p) => {\n          if (!this._within(p) && !this.state(\"dragging\")) {\n            this.state(\"hover\", false);\n            UI._trigger(this._actions[UA.leave], this, pt, UA.leave, evt);\n            this.off(UA.move, this._hoverID);\n            this.unhold(_capID);\n          }\n        });\n      }\n    });\n  }\n  onClick(fn) {\n    return this.on(UIPointerActions.up, fn);\n  }\n  offClick(id) {\n    return this.off(UIPointerActions.up, id);\n  }\n  onContextMenu(fn) {\n    return this.on(UIPointerActions.contextmenu, fn);\n  }\n  offContextMenu(id) {\n    return this.off(UIPointerActions.contextmenu, id);\n  }\n  onHover(enter, leave) {\n    var ids = [void 0, void 0];\n    if (enter)\n      ids[0] = this.on(UIPointerActions.enter, enter);\n    if (leave)\n      ids[1] = this.on(UIPointerActions.leave, leave);\n    return ids;\n  }\n  offHover(enterID, leaveID) {\n    var s = [false, false];\n    if (enterID === void 0 || enterID >= 0)\n      s[0] = this.off(UIPointerActions.enter, enterID);\n    if (leaveID === void 0 || leaveID >= 0)\n      s[1] = this.off(UIPointerActions.leave, leaveID);\n    return s;\n  }\n};\nvar UIDragger = class extends UIButton {\n  constructor(group, shape, states = {}, id) {\n    super(group, shape, states, id);\n    this._draggingID = -1;\n    this._moveHoldID = -1;\n    this._dropHoldID = -1;\n    this._upHoldID = -1;\n    if (states.dragging === void 0)\n      this._states[\"dragging\"] = false;\n    if (states.moved === void 0)\n      this._states[\"moved\"] = false;\n    if (states.offset === void 0)\n      this._states[\"offset\"] = new Pt();\n    const UA = UIPointerActions;\n    this.on(UA.down, (target, pt, type, evt) => {\n      if (this._moveHoldID === -1) {\n        this.state(\"dragging\", true);\n        this.state(\"offset\", new Pt(pt).subtract(target.group[0]));\n        this._moveHoldID = this.hold(UA.move);\n      }\n      if (this._dropHoldID === -1) {\n        this._dropHoldID = this.hold(UA.drop);\n      }\n      if (this._upHoldID === -1) {\n        this._upHoldID = this.hold(UA.up);\n      }\n      if (this._draggingID === -1) {\n        this._draggingID = this.on(UA.move, (t, p) => {\n          if (this.state(\"dragging\")) {\n            UI._trigger(this._actions[UA.uidrag], t, p, UA.uidrag, evt);\n            this.state(\"moved\", true);\n          }\n        });\n      }\n    });\n    const endDrag = (target, pt, type, evt) => {\n      this.state(\"dragging\", false);\n      this.off(UA.move, this._draggingID);\n      this._draggingID = -1;\n      this.unhold(this._moveHoldID);\n      this._moveHoldID = -1;\n      this.unhold(this._dropHoldID);\n      this._dropHoldID = -1;\n      this.unhold(this._upHoldID);\n      this._upHoldID = -1;\n      if (this.state(\"moved\")) {\n        UI._trigger(this._actions[UA.uidrop], target, pt, UA.uidrop, evt);\n        this.state(\"moved\", false);\n      }\n    };\n    this.on(UA.drop, endDrag);\n    this.on(UA.up, endDrag);\n    this.on(UA.out, endDrag);\n  }\n  onDrag(fn) {\n    return this.on(UIPointerActions.uidrag, fn);\n  }\n  offDrag(id) {\n    return this.off(UIPointerActions.uidrag, id);\n  }\n  onDrop(fn) {\n    return this.on(UIPointerActions.uidrop, fn);\n  }\n  offDrop(id) {\n    return this.off(UIPointerActions.uidrop, id);\n  }\n};\n\n// src/Space.ts\nvar Space = class {\n  constructor() {\n    this.id = \"space\";\n    this.bound = new Bound();\n    this._time = { prev: 0, diff: 0, end: -1, min: 0 };\n    this.players = {};\n    this.playerCount = 0;\n    this._animID = -1;\n    this._pause = false;\n    this._refresh = void 0;\n    this._pointer = new Pt();\n    this._isReady = false;\n    this._playing = false;\n  }\n  refresh(b) {\n    this._refresh = b;\n    return this;\n  }\n  minFrameTime(ms = 0) {\n    this._time.min = ms;\n  }\n  add(p) {\n    let player = typeof p == \"function\" ? { animate: p } : p;\n    let k = this.playerCount++;\n    let pid = this.id + k;\n    this.players[pid] = player;\n    player.animateID = pid;\n    if (player.resize && this.bound.inited)\n      player.resize(this.bound);\n    if (this._refresh === void 0)\n      this._refresh = true;\n    return this;\n  }\n  remove(player) {\n    delete this.players[player.animateID];\n    return this;\n  }\n  removeAll() {\n    this.players = {};\n    return this;\n  }\n  play(time = 0) {\n    if (time === 0 && this._animID !== -1) {\n      return;\n    }\n    this._animID = requestAnimationFrame(this.play.bind(this));\n    if (this._pause)\n      return this;\n    this._time.diff = time - this._time.prev;\n    if (this._time.diff < this._time.min)\n      return this;\n    this._time.prev = time;\n    try {\n      this.playItems(time);\n    } catch (err) {\n      cancelAnimationFrame(this._animID);\n      this._animID = -1;\n      this._playing = false;\n      throw err;\n    }\n    return this;\n  }\n  replay() {\n    this._time.end = -1;\n    this.play();\n  }\n  playItems(time) {\n    this._playing = true;\n    if (this._refresh)\n      this.clear();\n    if (this._isReady) {\n      for (let k in this.players) {\n        if (this.players[k].animate)\n          this.players[k].animate(time, this._time.diff, this);\n      }\n    }\n    if (this._time.end >= 0 && time > this._time.end) {\n      cancelAnimationFrame(this._animID);\n      this._animID = -1;\n      this._playing = false;\n    }\n  }\n  pause(toggle = false) {\n    this._pause = toggle ? !this._pause : true;\n    return this;\n  }\n  resume() {\n    this._pause = false;\n    return this;\n  }\n  stop(t = 0) {\n    this._time.end = t;\n    return this;\n  }\n  playOnce(duration = 0) {\n    this.play();\n    this.stop(duration);\n    return this;\n  }\n  render(context) {\n    if (this._renderFunc)\n      this._renderFunc(context, this);\n    return this;\n  }\n  set customRendering(f) {\n    this._renderFunc = f;\n  }\n  get customRendering() {\n    return this._renderFunc;\n  }\n  get isPlaying() {\n    return this._playing;\n  }\n  get outerBound() {\n    return this.bound.clone();\n  }\n  get innerBound() {\n    return new Bound(Pt.make(this.size.length, 0), this.size.clone());\n  }\n  get size() {\n    return this.bound.size.clone();\n  }\n  get center() {\n    return this.size.divide(2);\n  }\n  get width() {\n    return this.bound.width;\n  }\n  get height() {\n    return this.bound.height;\n  }\n};\nvar MultiTouchSpace = class extends Space {\n  constructor() {\n    super(...arguments);\n    this._pressed = false;\n    this._dragged = false;\n    this._hasMouse = false;\n    this._hasTouch = false;\n    this._hasKeyboard = false;\n  }\n  get pointer() {\n    let p = this._pointer.clone();\n    p.id = this._pointer.id;\n    return p;\n  }\n  bindCanvas(evt, callback, options = {}, customTarget) {\n    const target = customTarget ? customTarget : this._canvas;\n    target.addEventListener(evt, callback, options);\n  }\n  unbindCanvas(evt, callback, options = {}, customTarget) {\n    const target = customTarget ? customTarget : this._canvas;\n    target.removeEventListener(evt, callback, options);\n  }\n  bindDoc(evt, callback, options = {}) {\n    if (document) {\n      document.addEventListener(evt, callback, options);\n    }\n  }\n  unbindDoc(evt, callback, options = {}) {\n    if (document) {\n      document.removeEventListener(evt, callback, options);\n    }\n  }\n  bindMouse(bind = true, customTarget) {\n    if (bind) {\n      this._mouseDown = this._mouseDown.bind(this);\n      this._mouseUp = this._mouseUp.bind(this);\n      this._mouseOver = this._mouseOver.bind(this);\n      this._mouseOut = this._mouseOut.bind(this);\n      this._mouseMove = this._mouseMove.bind(this);\n      this._mouseClick = this._mouseClick.bind(this);\n      this._contextMenu = this._contextMenu.bind(this);\n      this.bindCanvas(\"mousedown\", this._mouseDown, {}, customTarget);\n      this.bindCanvas(\"mouseup\", this._mouseUp, {}, customTarget);\n      this.bindCanvas(\"mouseover\", this._mouseOver, {}, customTarget);\n      this.bindCanvas(\"mouseout\", this._mouseOut, {}, customTarget);\n      this.bindCanvas(\"mousemove\", this._mouseMove, {}, customTarget);\n      this.bindCanvas(\"click\", this._mouseClick, {}, customTarget);\n      this.bindCanvas(\"contextmenu\", this._contextMenu, {}, customTarget);\n      this._hasMouse = true;\n    } else {\n      this.unbindCanvas(\"mousedown\", this._mouseDown, {}, customTarget);\n      this.unbindCanvas(\"mouseup\", this._mouseUp, {}, customTarget);\n      this.unbindCanvas(\"mouseover\", this._mouseOver, {}, customTarget);\n      this.unbindCanvas(\"mouseout\", this._mouseOut, {}, customTarget);\n      this.unbindCanvas(\"mousemove\", this._mouseMove, {}, customTarget);\n      this.unbindCanvas(\"click\", this._mouseClick, {}, customTarget);\n      this.unbindCanvas(\"contextmenu\", this._contextMenu, {}, customTarget);\n      this._hasMouse = false;\n    }\n    return this;\n  }\n  bindTouch(bind = true, passive = false, customTarget) {\n    if (bind) {\n      this.bindCanvas(\"touchstart\", this._touchStart.bind(this), { passive }, customTarget);\n      this.bindCanvas(\"touchend\", this._mouseUp.bind(this), {}, customTarget);\n      this.bindCanvas(\"touchmove\", this._touchMove.bind(this), { passive }, customTarget);\n      this.bindCanvas(\"touchcancel\", this._mouseOut.bind(this), {}, customTarget);\n      this._hasTouch = true;\n    } else {\n      this.unbindCanvas(\"touchstart\", this._touchStart.bind(this), { passive }, customTarget);\n      this.unbindCanvas(\"touchend\", this._mouseUp.bind(this), {}, customTarget);\n      this.unbindCanvas(\"touchmove\", this._touchMove.bind(this), { passive }, customTarget);\n      this.unbindCanvas(\"touchcancel\", this._mouseOut.bind(this), {}, customTarget);\n      this._hasTouch = false;\n    }\n    return this;\n  }\n  bindKeyboard(bind = true) {\n    if (bind) {\n      this._keyDownBind = this._keyDown.bind(this);\n      this._keyUpBind = this._keyUp.bind(this);\n      this.bindDoc(\"keydown\", this._keyDownBind, {});\n      this.bindDoc(\"keyup\", this._keyUpBind, {});\n      this._hasKeyboard = true;\n    } else {\n      this.unbindDoc(\"keydown\", this._keyDownBind, {});\n      this.unbindDoc(\"keyup\", this._keyUpBind, {});\n      this._hasKeyboard = false;\n    }\n    return this;\n  }\n  touchesToPoints(evt, which = \"touches\") {\n    if (!evt || !evt[which])\n      return [];\n    let ts = [];\n    for (var i = 0; i < evt[which].length; i++) {\n      let t = evt[which].item(i);\n      ts.push(new Pt(t.pageX - this.bound.topLeft.x, t.pageY - this.bound.topLeft.y));\n    }\n    return ts;\n  }\n  _mouseAction(type, evt) {\n    if (!this.isPlaying)\n      return;\n    let px = 0, py = 0;\n    if (evt instanceof MouseEvent) {\n      for (let k in this.players) {\n        if (this.players.hasOwnProperty(k)) {\n          let v = this.players[k];\n          px = evt.pageX - this.outerBound.x;\n          py = evt.pageY - this.outerBound.y;\n          if (v.action)\n            v.action(type, px, py, evt);\n        }\n      }\n    } else {\n      for (let k in this.players) {\n        if (this.players.hasOwnProperty(k)) {\n          let v = this.players[k];\n          let c = evt.changedTouches && evt.changedTouches.length > 0;\n          let touch = evt.changedTouches.item(0);\n          px = c ? touch.pageX - this.outerBound.x : 0;\n          py = c ? touch.pageY - this.outerBound.y : 0;\n          if (v.action)\n            v.action(type, px, py, evt);\n        }\n      }\n    }\n    if (type) {\n      this._pointer.to(px, py);\n      this._pointer.id = type;\n    }\n  }\n  _mouseDown(evt) {\n    this._mouseAction(UIPointerActions.down, evt);\n    this._pressed = true;\n    return false;\n  }\n  _mouseUp(evt) {\n    if (this._dragged) {\n      this._mouseAction(UIPointerActions.drop, evt);\n    } else {\n      this._mouseAction(UIPointerActions.up, evt);\n    }\n    this._pressed = false;\n    this._dragged = false;\n    return false;\n  }\n  _mouseMove(evt) {\n    this._mouseAction(UIPointerActions.move, evt);\n    if (this._pressed) {\n      this._dragged = true;\n      this._mouseAction(UIPointerActions.drag, evt);\n    }\n    return false;\n  }\n  _mouseOver(evt) {\n    this._mouseAction(UIPointerActions.over, evt);\n    return false;\n  }\n  _mouseOut(evt) {\n    this._mouseAction(UIPointerActions.out, evt);\n    if (this._dragged)\n      this._mouseAction(UIPointerActions.drop, evt);\n    this._dragged = false;\n    return false;\n  }\n  _mouseClick(evt) {\n    this._mouseAction(UIPointerActions.click, evt);\n    this._pressed = false;\n    this._dragged = false;\n    return false;\n  }\n  _contextMenu(evt) {\n    this._mouseAction(UIPointerActions.contextmenu, evt);\n    return false;\n  }\n  _touchMove(evt) {\n    this._mouseMove(evt);\n    evt.preventDefault();\n    return false;\n  }\n  _touchStart(evt) {\n    this._mouseDown(evt);\n    evt.preventDefault();\n    return false;\n  }\n  _keyDown(evt) {\n    this._keyboardAction(UIPointerActions.keydown, evt);\n    return false;\n  }\n  _keyUp(evt) {\n    this._keyboardAction(UIPointerActions.keyup, evt);\n    return false;\n  }\n  _keyboardAction(type, evt) {\n    if (!this.isPlaying)\n      return;\n    for (let k in this.players) {\n      if (this.players.hasOwnProperty(k)) {\n        let v = this.players[k];\n        if (v.action)\n          v.action(type, evt.shiftKey ? 1 : 0, evt.altKey ? 1 : 0, evt);\n      }\n    }\n  }\n};\n\n// src/Form.ts\nvar Form = class {\n  constructor() {\n    this._ready = false;\n  }\n  get ready() {\n    return this._ready;\n  }\n};\nvar VisualForm = class extends Form {\n  constructor() {\n    super(...arguments);\n    this._filled = true;\n    this._stroked = true;\n    this._font = new Font(14, \"sans-serif\");\n  }\n  get filled() {\n    return this._filled;\n  }\n  set filled(b) {\n    this._filled = b;\n  }\n  get stroked() {\n    return this._stroked;\n  }\n  set stroked(b) {\n    this._stroked = b;\n  }\n  get currentFont() {\n    return this._font;\n  }\n  _multiple(groups, shape, ...rest) {\n    if (!groups)\n      return this;\n    for (let i = 0, len = groups.length; i < len; i++) {\n      this[shape](groups[i], ...rest);\n    }\n    return this;\n  }\n  alpha(a) {\n    return this;\n  }\n  fill(c) {\n    return this;\n  }\n  fillOnly(c) {\n    this.stroke(false);\n    return this.fill(c);\n  }\n  stroke(c, width, linejoin, linecap) {\n    return this;\n  }\n  strokeOnly(c, width, linejoin, linecap) {\n    this.fill(false);\n    return this.stroke(c, width, linejoin, linecap);\n  }\n  points(pts, radius, shape) {\n    if (!pts)\n      return;\n    for (let i = 0, len = pts.length; i < len; i++) {\n      this.point(pts[i], radius, shape);\n    }\n    return this;\n  }\n  circles(groups) {\n    return this._multiple(groups, \"circle\");\n  }\n  squares(groups) {\n    return this._multiple(groups, \"square\");\n  }\n  lines(groups) {\n    return this._multiple(groups, \"line\");\n  }\n  polygons(groups) {\n    return this._multiple(groups, \"polygon\");\n  }\n  rects(groups) {\n    return this._multiple(groups, \"rect\");\n  }\n};\nvar Font = class {\n  constructor(size = 12, face = \"sans-serif\", weight = \"\", style = \"\", lineHeight = 1.5) {\n    this.size = size;\n    this.face = face;\n    this.style = style;\n    this.weight = weight;\n    this.lineHeight = lineHeight;\n  }\n  get value() {\n    return `${this.style} ${this.weight} ${this.size}px/${this.lineHeight} ${this.face}`;\n  }\n  toString() {\n    return this.value;\n  }\n};\n\n// src/Typography.ts\nvar Typography = class {\n  static textWidthEstimator(fn, samples = [\"M\", \"n\", \".\"], distribution = [0.06, 0.8, 0.14]) {\n    let m = samples.map(fn);\n    let avg = new Pt(distribution).dot(m);\n    return (str) => str.length * avg;\n  }\n  static truncate(fn, str, width, tail = \"\") {\n    let trim = Math.floor(str.length * Math.min(1, width / fn(str)));\n    if (trim < str.length) {\n      trim = Math.max(0, trim - tail.length);\n      return [str.substr(0, trim) + tail, trim];\n    } else {\n      return [str, str.length];\n    }\n  }\n  static fontSizeToBox(box, ratio = 1, byHeight = true) {\n    let bound = Bound.fromGroup(box);\n    let h = byHeight ? bound.height : bound.width;\n    let f = ratio * h;\n    return function(box2) {\n      let bound2 = Bound.fromGroup(box2);\n      let nh = (byHeight ? bound2.height : bound2.width) / h;\n      return f * nh;\n    };\n  }\n  static fontSizeToThreshold(threshold, direction = 0) {\n    return function(defaultSize, val) {\n      let d = defaultSize * val / threshold;\n      if (direction < 0)\n        return Math.min(d, defaultSize);\n      if (direction > 0)\n        return Math.max(d, defaultSize);\n      return d;\n    };\n  }\n};\n\n// src/Image.ts\nvar Img = class {\n  constructor(editable = false, space, crossOrigin) {\n    this._scale = 1;\n    this._loaded = false;\n    this._editable = editable;\n    this._space = space;\n    this._scale = this._space ? this._space.pixelScale : 1;\n    this._img = new Image();\n    if (crossOrigin)\n      this._img.crossOrigin = \"Anonymous\";\n  }\n  static load(src, editable = false, space, ready) {\n    const img = new Img(editable, space);\n    img.load(src).then((res) => {\n      if (ready)\n        ready(res);\n    });\n    return img;\n  }\n  static async loadAsync(src, editable = false, space) {\n    const img = await new Img(editable, space).load(src);\n    return img;\n  }\n  static async loadPattern(src, space, repeat = \"repeat\", editable = false) {\n    const img = await Img.loadAsync(src, editable, space);\n    return img.pattern(repeat);\n  }\n  static blank(size, space, scale) {\n    let img = new Img(true, space);\n    const s = scale ? scale : space.pixelScale;\n    img.initCanvas(size[0], size[1], s);\n    return img;\n  }\n  load(src) {\n    return new Promise((resolve, reject) => {\n      if (this._editable && !document) {\n        reject(\"Cannot create html canvas element. document not found.\");\n      }\n      this._img.src = src;\n      this._img.onload = () => {\n        if (this._editable) {\n          if (!this._cv)\n            this._cv = document.createElement(\"canvas\");\n          this._drawToScale(this._scale, this._img);\n          this._data = this._ctx.getImageData(0, 0, this._cv.width, this._cv.height);\n        }\n        this._loaded = true;\n        resolve(this);\n      };\n      this._img.onerror = (evt) => {\n        reject(evt);\n      };\n    });\n  }\n  _drawToScale(canvasScale, img) {\n    const nw = img.width;\n    const nh = img.height;\n    this.initCanvas(nw, nh, canvasScale);\n    if (img)\n      this._ctx.drawImage(img, 0, 0, nw, nh, 0, 0, this._cv.width, this._cv.height);\n  }\n  initCanvas(width, height, canvasScale = 1) {\n    if (!this._editable) {\n      console.error(\"Cannot initiate canvas because this Img is not set to be editable\");\n      return;\n    }\n    if (!this._cv)\n      this._cv = document.createElement(\"canvas\");\n    const cms = typeof canvasScale === \"number\" ? [canvasScale, canvasScale] : canvasScale;\n    this._cv.width = width * cms[0];\n    this._cv.height = height * cms[1];\n    this._ctx = this._cv.getContext(\"2d\");\n    this._loaded = true;\n  }\n  bitmap(size) {\n    const w = size ? size[0] : this._cv.width;\n    const h = size ? size[1] : this._cv.height;\n    return createImageBitmap(this._cv, 0, 0, w, h);\n  }\n  pattern(reptition = \"repeat\", dynamic = false) {\n    if (!this._space)\n      throw \"Cannot find CanvasSpace ctx to create image pattern\";\n    return this._space.ctx.createPattern(dynamic ? this._cv : this._img, reptition);\n  }\n  sync() {\n    if (this._scale !== 1) {\n      this.bitmap().then((b) => {\n        this._drawToScale(1 / this._scale, b);\n        this.load(this.toBase64());\n      });\n    } else {\n      this._img.src = this.toBase64();\n    }\n  }\n  pixel(p, rescale = true) {\n    const s = typeof rescale == \"number\" ? rescale : rescale ? this._scale : 1;\n    return Img.getPixel(this._data, [p[0] * s, p[1] * s]);\n  }\n  static getPixel(imgData, p) {\n    const no = new Pt(0, 0, 0, 0);\n    if (p[0] >= imgData.width || p[1] >= imgData.height)\n      return no;\n    const i = Math.floor(p[1]) * (imgData.width * 4) + Math.floor(p[0]) * 4;\n    const d = imgData.data;\n    if (i >= d.length - 4)\n      return no;\n    return new Pt(d[i], d[i + 1], d[i + 2], d[i + 3]);\n  }\n  resize(sizeOrScale, asScale = false) {\n    let s = asScale ? sizeOrScale : [sizeOrScale[0] / this._img.naturalWidth, sizeOrScale[1] / this._img.naturalHeight];\n    this._drawToScale(s, this._img);\n    this._data = this._ctx.getImageData(0, 0, this._cv.width, this._cv.height);\n    return this;\n  }\n  crop(box) {\n    let p = box.topLeft.scale(this._scale);\n    let s = box.size.scale(this._scale);\n    return this._ctx.getImageData(p.x, p.y, s.x, s.y);\n  }\n  filter(css) {\n    this._ctx.filter = css;\n    this._ctx.drawImage(this._cv, 0, 0);\n    this._ctx.filter = \"none\";\n    return this;\n  }\n  cleanup() {\n    if (this._cv)\n      this._cv.remove();\n    if (this._img)\n      this._img.remove();\n    this._data = null;\n  }\n  static fromBlob(blob, editable = false, space) {\n    let url = URL.createObjectURL(blob);\n    return new Img(editable, space).load(url);\n  }\n  static imageDataToBlob(data) {\n    return new Promise(function(resolve, reject) {\n      if (!document) {\n        reject(\"Cannot create html canvas element. document not found.\");\n      }\n      let cv = document.createElement(\"canvas\");\n      cv.width = data.width;\n      cv.height = data.height;\n      cv.getContext(\"2d\").putImageData(data, 0, 0);\n      cv.toBlob((blob) => {\n        resolve(blob);\n        cv.remove();\n      });\n    });\n  }\n  toBase64() {\n    return this._cv.toDataURL();\n  }\n  toBlob() {\n    return new Promise((resolve) => {\n      this._cv.toBlob((blob) => resolve(blob));\n    });\n  }\n  getForm() {\n    if (!this._editable) {\n      console.error(\"Cannot get a CanvasForm because this Img is not editable\");\n    }\n    return this._ctx ? new CanvasForm(this._ctx) : void 0;\n  }\n  get current() {\n    return this._editable ? this._cv : this._img;\n  }\n  get image() {\n    return this._img;\n  }\n  get canvas() {\n    return this._cv;\n  }\n  get data() {\n    return this._data;\n  }\n  get ctx() {\n    return this._ctx;\n  }\n  get loaded() {\n    return this._loaded;\n  }\n  get pixelScale() {\n    return this._scale;\n  }\n  get imageSize() {\n    if (!this._img.width || !this._img.height) {\n      return this.canvasSize.$divide(this._scale);\n    } else {\n      return new Pt(this._img.width, this._img.height);\n    }\n  }\n  get canvasSize() {\n    return new Pt(this._cv.width, this._cv.height);\n  }\n  get scaledMatrix() {\n    const s = 1 / this._scale;\n    return new Mat().scale2D([s, s]);\n  }\n};\n\n// src/Canvas.ts\nvar CanvasSpace2 = class extends MultiTouchSpace {\n  constructor(elem, callback) {\n    super();\n    this._pixelScale = 1;\n    this._autoResize = true;\n    this._bgcolor = \"#e1e9f0\";\n    this._offscreen = false;\n    this._initialResize = false;\n    var _selector = null;\n    var _existed = false;\n    this.id = \"pt\";\n    if (elem instanceof Element) {\n      _selector = elem;\n      this.id = \"pts_existing_space\";\n    } else {\n      let id = elem;\n      id = elem[0] === \"#\" || elem[0] === \".\" ? elem : \"#\" + elem;\n      _selector = document.querySelector(id);\n      _existed = true;\n      this.id = id.substr(1);\n    }\n    if (!_selector) {\n      this._container = this._createElement(\"div\", this.id + \"_container\");\n      this._canvas = this._createElement(\"canvas\", this.id);\n      this._container.appendChild(this._canvas);\n      document.body.appendChild(this._container);\n      _existed = false;\n    } else if (_selector.nodeName.toLowerCase() != \"canvas\") {\n      this._container = _selector;\n      this._canvas = this._createElement(\"canvas\", this.id + \"_canvas\");\n      this._container.appendChild(this._canvas);\n      this._initialResize = true;\n    } else {\n      this._canvas = _selector;\n      this._container = _selector.parentElement;\n      this._autoResize = false;\n    }\n    setTimeout(this._ready.bind(this, callback), 100);\n    this._ctx = this._canvas.getContext(\"2d\");\n  }\n  _createElement(elem = \"div\", id) {\n    let d = document.createElement(elem);\n    d.setAttribute(\"id\", id);\n    return d;\n  }\n  _ready(callback) {\n    if (!this._container)\n      throw new Error(`Cannot initiate #${this.id} element`);\n    this._isReady = true;\n    this._resizeHandler(null);\n    this.clear(this._bgcolor);\n    this._canvas.dispatchEvent(new Event(\"ready\"));\n    for (let k in this.players) {\n      if (this.players.hasOwnProperty(k)) {\n        if (this.players[k].start)\n          this.players[k].start(this.bound.clone(), this);\n      }\n    }\n    this._pointer = this.center;\n    this._initialResize = false;\n    if (callback)\n      callback(this.bound, this._canvas);\n  }\n  setup(opt) {\n    this._bgcolor = opt.bgcolor ? opt.bgcolor : \"transparent\";\n    this.autoResize = opt.resize != void 0 ? opt.resize : false;\n    if (opt.retina !== false) {\n      let r1 = window ? window.devicePixelRatio || 1 : 1;\n      let r2 = this._ctx.webkitBackingStorePixelRatio || this._ctx.mozBackingStorePixelRatio || this._ctx.msBackingStorePixelRatio || this._ctx.oBackingStorePixelRatio || this._ctx.backingStorePixelRatio || 1;\n      this._pixelScale = Math.max(1, r1 / r2);\n    }\n    if (opt.offscreen) {\n      this._offscreen = true;\n      this._offCanvas = this._createElement(\"canvas\", this.id + \"_offscreen\");\n      this._offCtx = this._offCanvas.getContext(\"2d\");\n    } else {\n      this._offscreen = false;\n    }\n    if (opt.pixelDensity) {\n      this._pixelScale = opt.pixelDensity;\n    }\n    return this;\n  }\n  set autoResize(auto) {\n    if (!window)\n      return;\n    this._autoResize = auto;\n    if (auto) {\n      window.addEventListener(\"resize\", this._resizeHandler.bind(this));\n    } else {\n      window.removeEventListener(\"resize\", this._resizeHandler.bind(this));\n    }\n  }\n  get autoResize() {\n    return this._autoResize;\n  }\n  resize(b, evt) {\n    this.bound = b;\n    this._canvas.width = Math.ceil(this.bound.size.x) * this._pixelScale;\n    this._canvas.height = Math.ceil(this.bound.size.y) * this._pixelScale;\n    this._canvas.style.width = Math.ceil(this.bound.size.x) + \"px\";\n    this._canvas.style.height = Math.ceil(this.bound.size.y) + \"px\";\n    if (this._offscreen) {\n      this._offCanvas.width = Math.ceil(this.bound.size.x) * this._pixelScale;\n      this._offCanvas.height = Math.ceil(this.bound.size.y) * this._pixelScale;\n    }\n    if (this._pixelScale != 1) {\n      this._ctx.scale(this._pixelScale, this._pixelScale);\n      if (this._offscreen) {\n        this._offCtx.scale(this._pixelScale, this._pixelScale);\n      }\n    }\n    for (let k in this.players) {\n      if (this.players.hasOwnProperty(k)) {\n        let p = this.players[k];\n        if (p.resize)\n          p.resize(this.bound, evt);\n      }\n    }\n    this.render(this._ctx);\n    if (evt && !this.isPlaying)\n      this.playOnce(0);\n    return this;\n  }\n  _resizeHandler(evt) {\n    if (!window)\n      return;\n    let b = this._autoResize || this._initialResize ? this._container.getBoundingClientRect() : this._canvas.getBoundingClientRect();\n    if (b) {\n      let box = Bound.fromBoundingRect(b);\n      box.center = box.center.add(window.pageXOffset, window.pageYOffset);\n      this.resize(box, evt);\n    }\n  }\n  set background(bg) {\n    this._bgcolor = bg;\n  }\n  get background() {\n    return this._bgcolor;\n  }\n  get pixelScale() {\n    return this._pixelScale;\n  }\n  get hasOffscreen() {\n    return this._offscreen;\n  }\n  get offscreenCtx() {\n    return this._offCtx;\n  }\n  get offscreenCanvas() {\n    return this._offCanvas;\n  }\n  getForm() {\n    return new CanvasForm(this);\n  }\n  get element() {\n    return this._canvas;\n  }\n  get parent() {\n    return this._container;\n  }\n  get ready() {\n    return this._isReady;\n  }\n  get ctx() {\n    return this._ctx;\n  }\n  clear(bg) {\n    if (bg)\n      this._bgcolor = bg;\n    const lastColor = this._ctx.fillStyle;\n    const px = Math.ceil(this.pixelScale);\n    if (!this._bgcolor || this._bgcolor === \"transparent\") {\n      this._ctx.clearRect(-px, -px, this._canvas.width + px, this._canvas.height + px);\n    } else {\n      if (this._bgcolor.indexOf(\"rgba\") === 0 || this._bgcolor.length === 9 && this._bgcolor.indexOf(\"#\") === 0) {\n        this._ctx.clearRect(-px, -px, this._canvas.width + px, this._canvas.height + px);\n      }\n      this._ctx.fillStyle = this._bgcolor;\n      this._ctx.fillRect(-px, -px, this._canvas.width + px, this._canvas.height + px);\n    }\n    this._ctx.fillStyle = lastColor;\n    return this;\n  }\n  clearOffscreen(bg) {\n    if (this._offscreen) {\n      const px = Math.ceil(this.pixelScale);\n      if (bg) {\n        this._offCtx.fillStyle = bg;\n        this._offCtx.fillRect(-px, -px, this._canvas.width + px, this._canvas.height + px);\n      } else {\n        this._offCtx.clearRect(-px, -px, this._offCanvas.width + px, this._offCanvas.height + px);\n      }\n    }\n    return this;\n  }\n  playItems(time) {\n    if (this._isReady) {\n      this._ctx.save();\n      if (this._offscreen)\n        this._offCtx.save();\n      super.playItems(time);\n      this._ctx.restore();\n      if (this._offscreen)\n        this._offCtx.restore();\n      this.render(this._ctx);\n    }\n  }\n  dispose() {\n    if (!window)\n      return;\n    window.removeEventListener(\"resize\", this._resizeHandler.bind(this));\n    this.stop();\n    this.removeAll();\n    return this;\n  }\n  recorder(downloadOrCallback, filetype = \"webm\", bitrate = 15e6) {\n    let stream = this._canvas.captureStream();\n    const recorder = new MediaRecorder(stream, { mimeType: `video/${filetype}`, bitsPerSecond: bitrate });\n    recorder.ondataavailable = function(d) {\n      let url = URL.createObjectURL(new Blob([d.data], { type: `video/${filetype}` }));\n      if (typeof downloadOrCallback === \"function\") {\n        downloadOrCallback(url);\n      } else if (downloadOrCallback) {\n        let a = document.createElement(\"a\");\n        a.href = url;\n        a.download = `canvas_video.${filetype}`;\n        a.click();\n        a.remove();\n      }\n    };\n    return recorder;\n  }\n};\nvar CanvasForm = class extends VisualForm {\n  constructor(space) {\n    super();\n    this._style = {\n      fillStyle: \"#f03\",\n      strokeStyle: \"#fff\",\n      lineWidth: 1,\n      lineJoin: \"bevel\",\n      lineCap: \"butt\",\n      globalAlpha: 1\n    };\n    if (!space)\n      return this;\n    const _setup = (ctx) => {\n      this._ctx = ctx;\n      this._ctx.fillStyle = this._style.fillStyle;\n      this._ctx.strokeStyle = this._style.strokeStyle;\n      this._ctx.lineJoin = \"bevel\";\n      this._ctx.font = this._font.value;\n      this._ready = true;\n    };\n    if (space instanceof CanvasRenderingContext2D) {\n      _setup(space);\n    } else {\n      this._space = space;\n      this._space.add({ start: () => {\n        _setup(this._space.ctx);\n      } });\n    }\n  }\n  get space() {\n    return this._space;\n  }\n  get ctx() {\n    return this._ctx;\n  }\n  useOffscreen(off = true, clear = false) {\n    if (clear)\n      this._space.clearOffscreen(typeof clear == \"string\" ? clear : null);\n    this._ctx = this._space.hasOffscreen && off ? this._space.offscreenCtx : this._space.ctx;\n    return this;\n  }\n  renderOffscreen(offset = [0, 0]) {\n    if (this._space.hasOffscreen) {\n      this._space.ctx.drawImage(\n        this._space.offscreenCanvas,\n        offset[0],\n        offset[1],\n        this._space.width,\n        this._space.height\n      );\n    }\n  }\n  alpha(a) {\n    this._ctx.globalAlpha = a;\n    this._style.globalAlpha = a;\n    return this;\n  }\n  fill(c) {\n    if (typeof c == \"boolean\") {\n      this.filled = c;\n    } else {\n      this.filled = true;\n      this._style.fillStyle = c;\n      this._ctx.fillStyle = c;\n    }\n    return this;\n  }\n  stroke(c, width, linejoin, linecap) {\n    if (typeof c == \"boolean\") {\n      this.stroked = c;\n    } else {\n      this.stroked = true;\n      this._style.strokeStyle = c;\n      this._ctx.strokeStyle = c;\n      if (width) {\n        this._ctx.lineWidth = width;\n        this._style.lineWidth = width;\n      }\n      if (linejoin) {\n        this._ctx.lineJoin = linejoin;\n        this._style.lineJoin = linejoin;\n      }\n      if (linecap) {\n        this._ctx.lineCap = linecap;\n        this._style.lineCap = linecap;\n      }\n    }\n    return this;\n  }\n  applyFillStroke(filled = true, stroked = true, strokeWidth = 1) {\n    if (filled) {\n      if (typeof filled === \"string\")\n        this.fill(filled);\n      this._ctx.fill();\n    }\n    if (stroked) {\n      if (typeof stroked === \"string\")\n        this.stroke(stroked, strokeWidth);\n      this._ctx.stroke();\n    }\n    return this;\n  }\n  gradient(stops) {\n    let vals = [];\n    if (stops.length < 2)\n      stops.push([0.99, \"#000\"], [1, \"#000\"]);\n    for (let i = 0, len = stops.length; i < len; i++) {\n      let t = typeof stops[i] === \"string\" ? i * (1 / (stops.length - 1)) : stops[i][0];\n      let v = typeof stops[i] === \"string\" ? stops[i] : stops[i][1];\n      vals.push([t, v]);\n    }\n    return (area1, area2) => {\n      let grad = area2 ? this._ctx.createRadialGradient(area1[0][0], area1[0][1], Math.abs(area1[1][0]), area2[0][0], area2[0][1], Math.abs(area2[1][0])) : this._ctx.createLinearGradient(area1[0][0], area1[0][1], area1[1][0], area1[1][1]);\n      for (let i = 0, len = vals.length; i < len; i++) {\n        grad.addColorStop(vals[i][0], vals[i][1]);\n      }\n      return grad;\n    };\n  }\n  composite(mode = \"source-over\") {\n    this._ctx.globalCompositeOperation = mode;\n    return this;\n  }\n  clip() {\n    this._ctx.clip();\n    return this;\n  }\n  dash(segments = true, offset = 0) {\n    if (!segments) {\n      this._ctx.setLineDash([]);\n      this._ctx.lineDashOffset = 0;\n    } else {\n      if (segments === true) {\n        segments = [5, 5];\n      }\n      this._ctx.setLineDash([segments[0], segments[1]]);\n      this._ctx.lineDashOffset = offset;\n    }\n    return this;\n  }\n  font(sizeOrFont, weight, style, lineHeight, family) {\n    if (typeof sizeOrFont == \"number\") {\n      this._font.size = sizeOrFont;\n      if (family)\n        this._font.face = family;\n      if (weight)\n        this._font.weight = weight;\n      if (style)\n        this._font.style = style;\n      if (lineHeight)\n        this._font.lineHeight = lineHeight;\n    } else {\n      this._font = sizeOrFont;\n    }\n    this._ctx.font = this._font.value;\n    if (this._estimateTextWidth)\n      this.fontWidthEstimate(true);\n    return this;\n  }\n  fontWidthEstimate(estimate = true) {\n    this._estimateTextWidth = estimate ? Typography.textWidthEstimator((c) => this._ctx.measureText(c).width) : void 0;\n    return this;\n  }\n  getTextWidth(c) {\n    return !this._estimateTextWidth ? this._ctx.measureText(c + \" .\").width : this._estimateTextWidth(c);\n  }\n  _textTruncate(str, width, tail = \"\") {\n    return Typography.truncate(this.getTextWidth.bind(this), str, width, tail);\n  }\n  _textAlign(box, vertical, offset, center) {\n    let _box = Util.iterToArray(box);\n    if (!Util.arrayCheck(_box))\n      return;\n    if (!center)\n      center = Rectangle.center(_box);\n    var px = _box[0][0];\n    if (this._ctx.textAlign == \"end\" || this._ctx.textAlign == \"right\") {\n      px = _box[1][0];\n    } else if (this._ctx.textAlign == \"center\" || this._ctx.textAlign == \"middle\") {\n      px = center[0];\n    }\n    var py = center[1];\n    if (vertical == \"top\" || vertical == \"start\") {\n      py = _box[0][1];\n    } else if (vertical == \"end\" || vertical == \"bottom\") {\n      py = _box[1][1];\n    }\n    return offset ? new Pt(px + offset[0], py + offset[1]) : new Pt(px, py);\n  }\n  reset() {\n    for (let k in this._style) {\n      if (this._style.hasOwnProperty(k)) {\n        this._ctx[k] = this._style[k];\n      }\n    }\n    this._font = new Font();\n    this._ctx.font = this._font.value;\n    return this;\n  }\n  _paint() {\n    if (this._filled)\n      this._ctx.fill();\n    if (this._stroked)\n      this._ctx.stroke();\n  }\n  static point(ctx, p, radius = 5, shape = \"square\") {\n    if (!p)\n      return;\n    if (!CanvasForm[shape])\n      throw new Error(`${shape} is not a static function of CanvasForm`);\n    CanvasForm[shape](ctx, p, radius);\n  }\n  point(p, radius = 5, shape = \"square\") {\n    CanvasForm.point(this._ctx, p, radius, shape);\n    this._paint();\n    return this;\n  }\n  static circle(ctx, pt, radius = 10) {\n    if (!pt)\n      return;\n    ctx.beginPath();\n    ctx.arc(pt[0], pt[1], radius, 0, Const.two_pi, false);\n    ctx.closePath();\n  }\n  circle(pts) {\n    let p = Util.iterToArray(pts);\n    CanvasForm.circle(this._ctx, p[0], p[1][0]);\n    this._paint();\n    return this;\n  }\n  static ellipse(ctx, pt, radius, rotation = 0, startAngle = 0, endAngle = Const.two_pi, cc = false) {\n    if (!pt || !radius)\n      return;\n    ctx.beginPath();\n    ctx.ellipse(pt[0], pt[1], radius[0], radius[1], rotation, startAngle, endAngle, cc);\n  }\n  ellipse(pt, radius, rotation = 0, startAngle = 0, endAngle = Const.two_pi, cc = false) {\n    CanvasForm.ellipse(this._ctx, pt, radius, rotation, startAngle, endAngle, cc);\n    this._paint();\n    return this;\n  }\n  static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n    if (!pt)\n      return;\n    ctx.beginPath();\n    ctx.arc(pt[0], pt[1], radius, startAngle, endAngle, cc);\n  }\n  arc(pt, radius, startAngle, endAngle, cc) {\n    CanvasForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n    this._paint();\n    return this;\n  }\n  static square(ctx, pt, halfsize) {\n    if (!pt)\n      return;\n    let x1 = pt[0] - halfsize;\n    let y1 = pt[1] - halfsize;\n    let x2 = pt[0] + halfsize;\n    let y2 = pt[1] + halfsize;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x1, y2);\n    ctx.lineTo(x2, y2);\n    ctx.lineTo(x2, y1);\n    ctx.closePath();\n  }\n  square(pt, halfsize) {\n    CanvasForm.square(this._ctx, pt, halfsize);\n    this._paint();\n    return this;\n  }\n  static line(ctx, pts) {\n    if (!Util.arrayCheck(pts))\n      return;\n    let i = 0;\n    ctx.beginPath();\n    for (let it of pts) {\n      if (it) {\n        if (i++ > 0) {\n          ctx.lineTo(it[0], it[1]);\n        } else {\n          ctx.moveTo(it[0], it[1]);\n        }\n      }\n    }\n  }\n  line(pts) {\n    CanvasForm.line(this._ctx, pts);\n    this._paint();\n    return this;\n  }\n  static polygon(ctx, pts) {\n    if (!Util.arrayCheck(pts))\n      return;\n    CanvasForm.line(ctx, pts);\n    ctx.closePath();\n  }\n  polygon(pts) {\n    CanvasForm.polygon(this._ctx, pts);\n    this._paint();\n    return this;\n  }\n  static rect(ctx, pts) {\n    let p = Util.iterToArray(pts);\n    if (!Util.arrayCheck(p))\n      return;\n    ctx.beginPath();\n    ctx.moveTo(p[0][0], p[0][1]);\n    ctx.lineTo(p[0][0], p[1][1]);\n    ctx.lineTo(p[1][0], p[1][1]);\n    ctx.lineTo(p[1][0], p[0][1]);\n    ctx.closePath();\n  }\n  rect(pts) {\n    CanvasForm.rect(this._ctx, pts);\n    this._paint();\n    return this;\n  }\n  static image(ctx, ptOrRect, img, orig) {\n    let t = Util.iterToArray(ptOrRect);\n    let pos;\n    if (typeof t[0] === \"number\") {\n      pos = t;\n    } else {\n      if (orig) {\n        let o = Util.iterToArray(orig);\n        pos = [\n          o[0][0],\n          o[0][1],\n          o[1][0] - o[0][0],\n          o[1][1] - o[0][1],\n          t[0][0],\n          t[0][1],\n          t[1][0] - t[0][0],\n          t[1][1] - t[0][1]\n        ];\n      } else {\n        pos = [t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]];\n      }\n    }\n    if (img instanceof Img) {\n      if (img.loaded) {\n        ctx.drawImage(img.image, ...pos);\n      }\n    } else {\n      ctx.drawImage(img, ...pos);\n    }\n  }\n  image(ptOrRect, img, orig) {\n    if (img instanceof Img) {\n      if (img.loaded) {\n        CanvasForm.image(this._ctx, ptOrRect, img.image, orig);\n      }\n    } else {\n      CanvasForm.image(this._ctx, ptOrRect, img, orig);\n    }\n    return this;\n  }\n  static imageData(ctx, ptOrRect, img) {\n    let t = Util.iterToArray(ptOrRect);\n    if (typeof t[0] === \"number\") {\n      ctx.putImageData(img, t[0], t[1]);\n    } else {\n      ctx.putImageData(img, t[0][0], t[0][1], t[0][0], t[0][1], t[1][0], t[1][1]);\n    }\n  }\n  imageData(ptOrRect, img) {\n    CanvasForm.imageData(this._ctx, ptOrRect, img);\n    return this;\n  }\n  static text(ctx, pt, txt, maxWidth) {\n    if (!pt)\n      return;\n    ctx.fillText(txt, pt[0], pt[1], maxWidth);\n  }\n  text(pt, txt, maxWidth) {\n    CanvasForm.text(this._ctx, pt, txt, maxWidth);\n    return this;\n  }\n  textBox(box, txt, verticalAlign = \"middle\", tail = \"\", overrideBaseline = true) {\n    if (overrideBaseline)\n      this._ctx.textBaseline = verticalAlign;\n    let size = Rectangle.size(box);\n    let t = this._textTruncate(txt, size[0], tail);\n    this.text(this._textAlign(box, verticalAlign), t[0]);\n    return this;\n  }\n  paragraphBox(box, txt, lineHeight = 1.2, verticalAlign = \"top\", crop = true) {\n    let b = Util.iterToArray(box);\n    let size = Rectangle.size(b);\n    this._ctx.textBaseline = \"top\";\n    let lstep = this._font.size * lineHeight;\n    let nextLine = (sub, buffer = [], cc = 0) => {\n      if (!sub)\n        return buffer;\n      if (crop && cc * lstep > size[1] - lstep * 2)\n        return buffer;\n      if (cc > 1e4)\n        throw new Error(\"max recursion reached (10000)\");\n      let t = this._textTruncate(sub, size[0], \"\");\n      let newln = t[0].indexOf(\"\\n\");\n      if (newln >= 0) {\n        buffer.push(t[0].substr(0, newln));\n        return nextLine(sub.substr(newln + 1), buffer, cc + 1);\n      }\n      let dt = t[0].lastIndexOf(\" \") + 1;\n      if (dt <= 0 || t[1] === sub.length)\n        dt = void 0;\n      let line = t[0].substr(0, dt);\n      buffer.push(line);\n      return t[1] <= 0 || t[1] === sub.length ? buffer : nextLine(sub.substr(dt || t[1]), buffer, cc + 1);\n    };\n    let lines = nextLine(txt);\n    let lsize = lines.length * lstep;\n    let lbox = b;\n    if (verticalAlign == \"middle\" || verticalAlign == \"center\") {\n      let lpad = (size[1] - lsize) / 2;\n      if (crop)\n        lpad = Math.max(0, lpad);\n      lbox = new Group(b[0].$add(0, lpad), b[1].$subtract(0, lpad));\n    } else if (verticalAlign == \"bottom\") {\n      lbox = new Group(b[0].$add(0, size[1] - lsize), b[1]);\n    } else {\n      lbox = new Group(b[0], b[0].$add(size[0], lsize));\n    }\n    let center = Rectangle.center(lbox);\n    for (let i = 0, len = lines.length; i < len; i++) {\n      this.text(this._textAlign(lbox, \"top\", [0, i * lstep], center), lines[i]);\n    }\n    return this;\n  }\n  alignText(alignment = \"left\", baseline = \"alphabetic\") {\n    if (baseline == \"center\")\n      baseline = \"middle\";\n    if (baseline == \"baseline\")\n      baseline = \"alphabetic\";\n    this._ctx.textAlign = alignment;\n    this._ctx.textBaseline = baseline;\n    return this;\n  }\n  log(txt) {\n    let w = this._ctx.measureText(txt).width + 20;\n    this.stroke(false).fill(\"rgba(0,0,0,.4)\").rect([[0, 0], [w, 20]]);\n    this.fill(\"#fff\").text([10, 14], txt);\n    return this;\n  }\n};\n\n// src/Create.ts\nvar Create = class {\n  static distributeRandom(bound, count, dimensions = 2) {\n    let pts = new Group();\n    for (let i = 0; i < count; i++) {\n      let p = [bound.x + Num.random() * bound.width];\n      if (dimensions > 1)\n        p.push(bound.y + Num.random() * bound.height);\n      if (dimensions > 2)\n        p.push(bound.z + Num.random() * bound.depth);\n      pts.push(new Pt(p));\n    }\n    return pts;\n  }\n  static distributeLinear(line, count) {\n    let _line = Util.iterToArray(line);\n    let ln = Line.subpoints(_line, count - 2);\n    ln.unshift(_line[0]);\n    ln.push(_line[_line.length - 1]);\n    return ln;\n  }\n  static gridPts(bound, columns, rows, orientation = [0.5, 0.5]) {\n    if (columns === 0 || rows === 0)\n      throw new Error(\"grid columns and rows cannot be 0\");\n    let unit = bound.size.$subtract(1).$divide(columns, rows);\n    let offset = unit.$multiply(orientation);\n    let g = new Group();\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < columns; c++) {\n        g.push(bound.topLeft.$add(unit.$multiply(c, r)).add(offset));\n      }\n    }\n    return g;\n  }\n  static gridCells(bound, columns, rows) {\n    if (columns === 0 || rows === 0)\n      throw new Error(\"grid columns and rows cannot be 0\");\n    let unit = bound.size.$subtract(1).divide(columns, rows);\n    let g = [];\n    for (let r = 0; r < rows; r++) {\n      for (let c = 0; c < columns; c++) {\n        g.push(new Group(\n          bound.topLeft.$add(unit.$multiply(c, r)),\n          bound.topLeft.$add(unit.$multiply(c, r).add(unit))\n        ));\n      }\n    }\n    return g;\n  }\n  static radialPts(center, radius, count, angleOffset = -Const.half_pi) {\n    let g = new Group();\n    let a = Const.two_pi / count;\n    for (let i = 0; i < count; i++) {\n      g.push(new Pt(center).toAngle(a * i + angleOffset, radius, true));\n    }\n    return g;\n  }\n  static noisePts(pts, dx = 0.01, dy = 0.01, rows = 0, columns = 0) {\n    let seed = Num.random();\n    let g = new Group();\n    let i = 0;\n    for (let p of pts) {\n      let np = new Noise(p);\n      let r = rows && rows > 0 ? Math.floor(i / rows) : i;\n      let c = columns && columns > 0 ? i % columns : i;\n      np.initNoise(dx * c, dy * r);\n      np.seed(seed);\n      g.push(np);\n      i++;\n    }\n    return g;\n  }\n  static delaunay(pts) {\n    return Delaunay.from(pts);\n  }\n};\nvar __noise_grad3 = [\n  [1, 1, 0],\n  [-1, 1, 0],\n  [1, -1, 0],\n  [-1, -1, 0],\n  [1, 0, 1],\n  [-1, 0, 1],\n  [1, 0, -1],\n  [-1, 0, -1],\n  [0, 1, 1],\n  [0, -1, 1],\n  [0, 1, -1],\n  [0, -1, -1]\n];\nvar __noise_permTable = [\n  151,\n  160,\n  137,\n  91,\n  90,\n  15,\n  131,\n  13,\n  201,\n  95,\n  96,\n  53,\n  194,\n  233,\n  7,\n  225,\n  140,\n  36,\n  103,\n  30,\n  69,\n  142,\n  8,\n  99,\n  37,\n  240,\n  21,\n  10,\n  23,\n  190,\n  6,\n  148,\n  247,\n  120,\n  234,\n  75,\n  0,\n  26,\n  197,\n  62,\n  94,\n  252,\n  219,\n  203,\n  117,\n  35,\n  11,\n  32,\n  57,\n  177,\n  33,\n  88,\n  237,\n  149,\n  56,\n  87,\n  174,\n  20,\n  125,\n  136,\n  171,\n  168,\n  68,\n  175,\n  74,\n  165,\n  71,\n  134,\n  139,\n  48,\n  27,\n  166,\n  77,\n  146,\n  158,\n  231,\n  83,\n  111,\n  229,\n  122,\n  60,\n  211,\n  133,\n  230,\n  220,\n  105,\n  92,\n  41,\n  55,\n  46,\n  245,\n  40,\n  244,\n  102,\n  143,\n  54,\n  65,\n  25,\n  63,\n  161,\n  1,\n  216,\n  80,\n  73,\n  209,\n  76,\n  132,\n  187,\n  208,\n  89,\n  18,\n  169,\n  200,\n  196,\n  135,\n  130,\n  116,\n  188,\n  159,\n  86,\n  164,\n  100,\n  109,\n  198,\n  173,\n  186,\n  3,\n  64,\n  52,\n  217,\n  226,\n  250,\n  124,\n  123,\n  5,\n  202,\n  38,\n  147,\n  118,\n  126,\n  255,\n  82,\n  85,\n  212,\n  207,\n  206,\n  59,\n  227,\n  47,\n  16,\n  58,\n  17,\n  182,\n  189,\n  28,\n  42,\n  223,\n  183,\n  170,\n  213,\n  119,\n  248,\n  152,\n  2,\n  44,\n  154,\n  163,\n  70,\n  221,\n  153,\n  101,\n  155,\n  167,\n  43,\n  172,\n  9,\n  129,\n  22,\n  39,\n  253,\n  9,\n  98,\n  108,\n  110,\n  79,\n  113,\n  224,\n  232,\n  178,\n  185,\n  112,\n  104,\n  218,\n  246,\n  97,\n  228,\n  251,\n  34,\n  242,\n  193,\n  238,\n  210,\n  144,\n  12,\n  191,\n  179,\n  162,\n  241,\n  81,\n  51,\n  145,\n  235,\n  249,\n  14,\n  239,\n  107,\n  49,\n  192,\n  214,\n  31,\n  181,\n  199,\n  106,\n  157,\n  184,\n  84,\n  204,\n  176,\n  115,\n  121,\n  50,\n  45,\n  127,\n  4,\n  150,\n  254,\n  138,\n  236,\n  205,\n  93,\n  222,\n  114,\n  67,\n  29,\n  24,\n  72,\n  243,\n  141,\n  128,\n  195,\n  78,\n  66,\n  215,\n  61,\n  156,\n  180\n];\nvar Noise = class extends Pt {\n  constructor(...args) {\n    super(...args);\n    this.perm = [];\n    this._n = new Pt(0.01, 0.01);\n    this.perm = __noise_permTable.concat(__noise_permTable);\n  }\n  initNoise(...args) {\n    this._n = new Pt(...args);\n    return this;\n  }\n  step(x = 0, y = 0) {\n    this._n.add(x, y);\n    return this;\n  }\n  seed(s) {\n    if (s > 0 && s < 1)\n      s *= 65536;\n    s = Math.floor(s);\n    if (s < 256)\n      s |= s << 8;\n    for (let i = 0; i < 255; i++) {\n      let v = i & 1 ? __noise_permTable[i] ^ s & 255 : __noise_permTable[i] ^ s >> 8 & 255;\n      this.perm[i] = this.perm[i + 256] = v;\n    }\n    return this;\n  }\n  noise2D() {\n    let i = Math.max(0, Math.floor(this._n[0])) % 255;\n    let j = Math.max(0, Math.floor(this._n[1])) % 255;\n    let x = this._n[0] % 255 - i;\n    let y = this._n[1] % 255 - j;\n    let n00 = Vec.dot(__noise_grad3[(i + this.perm[j]) % 12], [x, y, 0]);\n    let n01 = Vec.dot(__noise_grad3[(i + this.perm[j + 1]) % 12], [x, y - 1, 0]);\n    let n10 = Vec.dot(__noise_grad3[(i + 1 + this.perm[j]) % 12], [x - 1, y, 0]);\n    let n11 = Vec.dot(__noise_grad3[(i + 1 + this.perm[j + 1]) % 12], [x - 1, y - 1, 0]);\n    let _fade = (f) => f * f * f * (f * (f * 6 - 15) + 10);\n    let tx = _fade(x);\n    return Num.lerp(Num.lerp(n00, n10, tx), Num.lerp(n01, n11, tx), _fade(y));\n  }\n};\nvar Delaunay = class extends Group {\n  constructor() {\n    super(...arguments);\n    this._mesh = [];\n  }\n  delaunay(triangleOnly = true) {\n    if (this.length < 3)\n      return [];\n    this._mesh = [];\n    let n = this.length;\n    let indices = [];\n    for (let i = 0; i < n; i++)\n      indices[i] = i;\n    indices.sort((i, j) => this[j][0] - this[i][0]);\n    let pts = this.slice();\n    let st = this._superTriangle();\n    pts = pts.concat(st);\n    let opened = [this._circum(n, n + 1, n + 2, st)];\n    let closed = [];\n    let tris = [];\n    for (let i = 0, len = indices.length; i < len; i++) {\n      let c = indices[i];\n      let edges = [];\n      let j = opened.length;\n      if (!this._mesh[c])\n        this._mesh[c] = {};\n      while (j--) {\n        let circum = opened[j];\n        let radius = circum.circle[1][0];\n        let d = pts[c].$subtract(circum.circle[0]);\n        if (d[0] > 0 && d[0] * d[0] > radius * radius) {\n          closed.push(circum);\n          tris.push(circum.triangle);\n          opened.splice(j, 1);\n          continue;\n        }\n        if (d[0] * d[0] + d[1] * d[1] - radius * radius > Const.epsilon) {\n          continue;\n        }\n        edges.push(circum.i, circum.j, circum.j, circum.k, circum.k, circum.i);\n        opened.splice(j, 1);\n      }\n      Delaunay._dedupe(edges);\n      j = edges.length;\n      while (j > 1) {\n        opened.push(this._circum(edges[--j], edges[--j], c, false, pts));\n      }\n    }\n    for (let i = 0, len = opened.length; i < len; i++) {\n      let o = opened[i];\n      if (o.i < n && o.j < n && o.k < n) {\n        closed.push(o);\n        tris.push(o.triangle);\n        this._cache(o);\n      }\n    }\n    return triangleOnly ? tris : closed;\n  }\n  voronoi() {\n    let vs = [];\n    let n = this._mesh;\n    for (let i = 0, len = n.length; i < len; i++) {\n      vs.push(this.neighborPts(i, true));\n    }\n    return vs;\n  }\n  mesh() {\n    return this._mesh;\n  }\n  neighborPts(i, sort = false) {\n    let cs = new Group();\n    let n = this._mesh;\n    for (let k in n[i]) {\n      if (n[i].hasOwnProperty(k))\n        cs.push(n[i][k].circle[0]);\n    }\n    return sort ? Geom.sortEdges(cs) : cs;\n  }\n  neighbors(i) {\n    let cs = [];\n    let n = this._mesh;\n    for (let k in n[i]) {\n      if (n[i].hasOwnProperty(k))\n        cs.push(n[i][k]);\n    }\n    return cs;\n  }\n  _cache(o) {\n    this._mesh[o.i][`${Math.min(o.j, o.k)}-${Math.max(o.j, o.k)}`] = o;\n    this._mesh[o.j][`${Math.min(o.i, o.k)}-${Math.max(o.i, o.k)}`] = o;\n    this._mesh[o.k][`${Math.min(o.i, o.j)}-${Math.max(o.i, o.j)}`] = o;\n  }\n  _superTriangle() {\n    let minPt = this[0];\n    let maxPt = this[0];\n    for (let i = 1, len = this.length; i < len; i++) {\n      minPt = minPt.$min(this[i]);\n      maxPt = maxPt.$max(this[i]);\n    }\n    let d = maxPt.$subtract(minPt);\n    let mid = minPt.$add(maxPt).divide(2);\n    let dmax = Math.max(d[0], d[1]);\n    return new Group(mid.$subtract(20 * dmax, dmax), mid.$add(0, 20 * dmax), mid.$add(20 * dmax, -dmax));\n  }\n  _triangle(i, j, k, pts = this) {\n    return new Group(pts[i], pts[j], pts[k]);\n  }\n  _circum(i, j, k, tri, pts = this) {\n    let t = tri || this._triangle(i, j, k, pts);\n    return {\n      i,\n      j,\n      k,\n      triangle: t,\n      circle: Triangle.circumcircle(t)\n    };\n  }\n  static _dedupe(edges) {\n    let j = edges.length;\n    while (j > 1) {\n      let b = edges[--j];\n      let a = edges[--j];\n      let i = j;\n      while (i > 1) {\n        let n = edges[--i];\n        let m = edges[--i];\n        if (a == m && b == n || a == n && b == m) {\n          edges.splice(j, 2);\n          edges.splice(i, 2);\n          break;\n        }\n      }\n    }\n    return edges;\n  }\n};\n\n// src/Color.ts\nvar _Color = class extends Pt {\n  constructor(...args) {\n    super(...args);\n    this._mode = \"rgb\";\n    this._isNorm = false;\n  }\n  static from(...args) {\n    let p = [1, 1, 1, 1];\n    let c = Util.getArgs(args);\n    for (let i = 0, len = p.length; i < len; i++) {\n      if (i < c.length)\n        p[i] = c[i];\n    }\n    return new _Color(p);\n  }\n  static fromHex(hex) {\n    if (hex[0] == \"#\")\n      hex = hex.substr(1);\n    if (hex.length <= 3) {\n      let fn = (i) => hex[i] || \"F\";\n      hex = `${fn(0)}${fn(0)}${fn(1)}${fn(1)}${fn(2)}${fn(2)}`;\n    }\n    let alpha = 1;\n    if (hex.length === 8) {\n      alpha = hex.substr(6) && 255 / 255;\n      hex = hex.substring(0, 6);\n    }\n    let hexVal = parseInt(hex, 16);\n    return new _Color(hexVal >> 16, hexVal >> 8 & 255, hexVal & 255, alpha);\n  }\n  static rgb(...args) {\n    return _Color.from(...args).toMode(\"rgb\");\n  }\n  static hsl(...args) {\n    return _Color.from(...args).toMode(\"hsl\");\n  }\n  static hsb(...args) {\n    return _Color.from(...args).toMode(\"hsb\");\n  }\n  static lab(...args) {\n    return _Color.from(...args).toMode(\"lab\");\n  }\n  static lch(...args) {\n    return _Color.from(...args).toMode(\"lch\");\n  }\n  static luv(...args) {\n    return _Color.from(...args).toMode(\"luv\");\n  }\n  static xyz(...args) {\n    return _Color.from(...args).toMode(\"xyz\");\n  }\n  static maxValues(mode) {\n    return _Color.ranges[mode].zipSlice(1).$take([0, 1, 2]);\n  }\n  get hex() {\n    return this.toString(\"hex\");\n  }\n  get rgb() {\n    return this.toString(\"rgb\");\n  }\n  get rgba() {\n    return this.toString(\"rgba\");\n  }\n  clone() {\n    let c = new _Color(this);\n    c.toMode(this._mode);\n    return c;\n  }\n  toMode(mode, convert = false) {\n    if (convert) {\n      let fname = this._mode.toUpperCase() + \"to\" + mode.toUpperCase();\n      if (_Color[fname]) {\n        this.to(_Color[fname](this, this._isNorm, this._isNorm));\n      } else {\n        throw new Error(\"Cannot convert color with \" + fname);\n      }\n    }\n    this._mode = mode;\n    return this;\n  }\n  get mode() {\n    return this._mode;\n  }\n  get r() {\n    return this[0];\n  }\n  set r(n) {\n    this[0] = n;\n  }\n  get g() {\n    return this[1];\n  }\n  set g(n) {\n    this[1] = n;\n  }\n  get b() {\n    return this[2];\n  }\n  set b(n) {\n    this[2] = n;\n  }\n  get h() {\n    return this._mode == \"lch\" ? this[2] : this[0];\n  }\n  set h(n) {\n    let i = this._mode == \"lch\" ? 2 : 0;\n    this[i] = n;\n  }\n  get s() {\n    return this[1];\n  }\n  set s(n) {\n    this[1] = n;\n  }\n  get l() {\n    return this._mode == \"hsl\" ? this[2] : this[0];\n  }\n  set l(n) {\n    let i = this._mode == \"hsl\" ? 2 : 0;\n    this[i] = n;\n  }\n  get a() {\n    return this[1];\n  }\n  set a(n) {\n    this[1] = n;\n  }\n  get c() {\n    return this[1];\n  }\n  set c(n) {\n    this[1] = n;\n  }\n  get u() {\n    return this[1];\n  }\n  set u(n) {\n    this[1] = n;\n  }\n  get v() {\n    return this[2];\n  }\n  set v(n) {\n    this[2] = n;\n  }\n  set alpha(n) {\n    if (this.length > 3)\n      this[3] = n;\n  }\n  get alpha() {\n    return this.length > 3 ? this[3] : 1;\n  }\n  get normalized() {\n    return this._isNorm;\n  }\n  set normalized(b) {\n    this._isNorm = b;\n  }\n  normalize(toNorm = true) {\n    if (this._isNorm == toNorm)\n      return this;\n    let ranges = _Color.ranges[this._mode];\n    for (let i = 0; i < 3; i++) {\n      this[i] = !toNorm ? Num.mapToRange(this[i], 0, 1, ranges[i][0], ranges[i][1]) : Num.mapToRange(this[i], ranges[i][0], ranges[i][1], 0, 1);\n    }\n    this._isNorm = toNorm;\n    return this;\n  }\n  $normalize(toNorm = true) {\n    return this.clone().normalize(toNorm);\n  }\n  toString(format = \"mode\") {\n    if (format == \"hex\") {\n      let _hex = (n) => {\n        let s = Math.floor(n).toString(16);\n        return s.length < 2 ? \"0\" + s : s;\n      };\n      return `#${_hex(this[0])}${_hex(this[1])}${_hex(this[2])}`;\n    } else if (format == \"rgba\") {\n      return `rgba(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])},${this.alpha})`;\n    } else if (format == \"rgb\") {\n      return `rgb(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])})`;\n    } else {\n      return `${this._mode}(${this[0]},${this[1]},${this[2]},${this.alpha})`;\n    }\n  }\n  static RGBtoHSL(rgb, normalizedInput = false, normalizedOutput = false) {\n    let [r, g, b] = !normalizedInput ? rgb.$normalize() : rgb;\n    let max = Math.max(r, g, b);\n    let min = Math.min(r, g, b);\n    let h = (max + min) / 2;\n    let s = h;\n    let l = h;\n    if (max == min) {\n      h = 0;\n      s = 0;\n    } else {\n      let d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = 0;\n      if (max === r) {\n        h = (g - b) / d + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / d + 2;\n      } else if (max === b) {\n        h = (r - g) / d + 4;\n      }\n    }\n    return _Color.hsl(normalizedOutput ? h / 60 : h * 60, s, l, rgb.alpha);\n  }\n  static HSLtoRGB(hsl, normalizedInput = false, normalizedOutput = false) {\n    let [h, s, l] = hsl;\n    if (!normalizedInput)\n      h = h / 360;\n    if (s == 0)\n      return _Color.rgb(l * 255, l * 255, l * 255, hsl.alpha);\n    let q = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n    let p = 2 * l - q;\n    let convert = (t) => {\n      t = t < 0 ? t + 1 : t > 1 ? t - 1 : t;\n      if (t * 6 < 1) {\n        return p + (q - p) * t * 6;\n      } else if (t * 2 < 1) {\n        return q;\n      } else if (t * 3 < 2) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n      } else {\n        return p;\n      }\n    };\n    let sc = normalizedOutput ? 1 : 255;\n    return _Color.rgb(\n      sc * convert(h + 1 / 3),\n      sc * convert(h),\n      sc * convert(h - 1 / 3),\n      hsl.alpha\n    );\n  }\n  static RGBtoHSB(rgb, normalizedInput = false, normalizedOutput = false) {\n    let [r, g, b] = !normalizedInput ? rgb.$normalize() : rgb;\n    let max = Math.max(r, g, b);\n    let min = Math.min(r, g, b);\n    let d = max - min;\n    let h = 0;\n    let s = max === 0 ? 0 : d / max;\n    let v = max;\n    if (max != min) {\n      if (max === r) {\n        h = (g - b) / d + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / d + 2;\n      } else if (max === b) {\n        h = (r - g) / d + 4;\n      }\n    }\n    return _Color.hsb(normalizedOutput ? h / 60 : h * 60, s, v, rgb.alpha);\n  }\n  static HSBtoRGB(hsb, normalizedInput = false, normalizedOutput = false) {\n    let [h, s, v] = hsb;\n    if (!normalizedInput)\n      h = h / 360;\n    let i = Math.floor(h * 6);\n    let f = h * 6 - i;\n    let p = v * (1 - s);\n    let q = v * (1 - f * s);\n    let t = v * (1 - (1 - f) * s);\n    let pick = [\n      [v, t, p],\n      [q, v, p],\n      [p, v, t],\n      [p, q, v],\n      [t, p, v],\n      [v, p, q]\n    ];\n    let c = pick[i % 6];\n    let sc = normalizedOutput ? 1 : 255;\n    return _Color.rgb(\n      sc * c[0],\n      sc * c[1],\n      sc * c[2],\n      hsb.alpha\n    );\n  }\n  static RGBtoLAB(rgb, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? rgb.$normalize(false) : rgb;\n    return _Color.XYZtoLAB(_Color.RGBtoXYZ(c), false, normalizedOutput);\n  }\n  static LABtoRGB(lab, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lab.$normalize(false) : lab;\n    return _Color.XYZtoRGB(_Color.LABtoXYZ(c), false, normalizedOutput);\n  }\n  static RGBtoLCH(rgb, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? rgb.$normalize(false) : rgb;\n    return _Color.LABtoLCH(_Color.RGBtoLAB(c), false, normalizedOutput);\n  }\n  static LCHtoRGB(lch, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lch.$normalize(false) : lch;\n    return _Color.LABtoRGB(_Color.LCHtoLAB(c), false, normalizedOutput);\n  }\n  static RGBtoLUV(rgb, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? rgb.$normalize(false) : rgb;\n    return _Color.XYZtoLUV(_Color.RGBtoXYZ(c), false, normalizedOutput);\n  }\n  static LUVtoRGB(luv, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? luv.$normalize(false) : luv;\n    return _Color.XYZtoRGB(_Color.LUVtoXYZ(c), false, normalizedOutput);\n  }\n  static RGBtoXYZ(rgb, normalizedInput = false, normalizedOutput = false) {\n    let c = !normalizedInput ? rgb.$normalize() : rgb.clone();\n    for (let i = 0; i < 3; i++) {\n      c[i] = c[i] > 0.04045 ? Math.pow((c[i] + 0.055) / 1.055, 2.4) : c[i] / 12.92;\n      if (!normalizedOutput)\n        c[i] = c[i] * 100;\n    }\n    let cc = _Color.xyz(\n      c[0] * 0.4124564 + c[1] * 0.3575761 + c[2] * 0.1804375,\n      c[0] * 0.2126729 + c[1] * 0.7151522 + c[2] * 0.072175,\n      c[0] * 0.0193339 + c[1] * 0.119192 + c[2] * 0.9503041,\n      rgb.alpha\n    );\n    return normalizedOutput ? cc.normalize() : cc;\n  }\n  static XYZtoRGB(xyz, normalizedInput = false, normalizedOutput = false) {\n    let [x, y, z] = !normalizedInput ? xyz.$normalize() : xyz;\n    let rgb = [\n      x * 3.2406254773200533 + y * -1.5372079722103187 + z * -0.4986285986982479,\n      x * -0.9689307147293197 + y * 1.8757560608852415 + z * 0.041517523842953964,\n      x * 0.055710120445510616 + y * -0.2040210505984867 + z * 1.0569959422543882\n    ];\n    for (let i = 0; i < 3; i++) {\n      rgb[i] = rgb[i] > 31308e-7 ? 1.055 * Math.pow(rgb[i], 1 / 2.4) - 0.055 : 12.92 * rgb[i];\n      rgb[i] = Math.max(0, Math.min(1, rgb[i]));\n      if (!normalizedOutput)\n        rgb[i] = Math.round(rgb[i] * 255);\n    }\n    let cc = _Color.rgb(rgb[0], rgb[1], rgb[2], xyz.alpha);\n    return normalizedOutput ? cc.normalize() : cc;\n  }\n  static XYZtoLAB(xyz, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? xyz.$normalize(false) : xyz.clone();\n    const eps = 0.00885645167;\n    const kap = 903.296296296;\n    c.divide(_Color.D65);\n    let fn = (n) => n > eps ? Math.pow(n, 1 / 3) : (kap * n + 16) / 116;\n    let cy = fn(c[1]);\n    let cc = _Color.lab(\n      116 * cy - 16,\n      500 * (fn(c[0]) - cy),\n      200 * (cy - fn(c[2])),\n      xyz.alpha\n    );\n    return normalizedOutput ? cc.normalize() : cc;\n  }\n  static LABtoXYZ(lab, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lab.$normalize(false) : lab;\n    let y = (c[0] + 16) / 116;\n    let x = c[1] / 500 + y;\n    let z = y - c[2] / 200;\n    const eps = 0.00885645167;\n    const kap = 903.296296296;\n    let d = _Color.D65;\n    const xxx = Math.pow(x, 3);\n    const zzz = Math.pow(z, 3);\n    let cc = _Color.xyz(\n      d[0] * (xxx > eps ? xxx : (116 * x - 16) / kap),\n      d[1] * (c[0] > kap * eps ? Math.pow((c[0] + 16) / 116, 3) : c[0] / kap),\n      d[2] * (zzz > eps ? zzz : (116 * z - 16) / kap),\n      lab.alpha\n    );\n    return normalizedOutput ? cc.normalize() : cc;\n  }\n  static XYZtoLUV(xyz, normalizedInput = false, normalizedOutput = false) {\n    let [x, y, z] = normalizedInput ? xyz.$normalize(false) : xyz;\n    let u = 4 * x / (x + 15 * y + 3 * z);\n    let v = 9 * y / (x + 15 * y + 3 * z);\n    y = y / 100;\n    y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n    let refU = 4 * _Color.D65[0] / (_Color.D65[0] + 15 * _Color.D65[1] + 3 * _Color.D65[2]);\n    let refV = 9 * _Color.D65[1] / (_Color.D65[0] + 15 * _Color.D65[1] + 3 * _Color.D65[2]);\n    let L = 116 * y - 16;\n    return _Color.luv(\n      L,\n      13 * L * (u - refU),\n      13 * L * (v - refV),\n      xyz.alpha\n    );\n  }\n  static LUVtoXYZ(luv, normalizedInput = false, normalizedOutput = false) {\n    let [l, u, v] = normalizedInput ? luv.$normalize(false) : luv;\n    let y = (l + 16) / 116;\n    let cubeY = y * y * y;\n    y = cubeY > 8856e-6 ? cubeY : (y - 16 / 116) / 7.787;\n    let refU = 4 * _Color.D65[0] / (_Color.D65[0] + 15 * _Color.D65[1] + 3 * _Color.D65[2]);\n    let refV = 9 * _Color.D65[1] / (_Color.D65[0] + 15 * _Color.D65[1] + 3 * _Color.D65[2]);\n    u = u / (13 * l) + refU;\n    v = v / (13 * l) + refV;\n    y = y * 100;\n    let x = -1 * (9 * y * u) / ((u - 4) * v - u * v);\n    let z = (9 * y - 15 * v * y - v * x) / (3 * v);\n    return _Color.xyz(x, y, z, luv.alpha);\n  }\n  static LABtoLCH(lab, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lab.$normalize(false) : lab;\n    let h = Geom.toDegree(Geom.boundRadian(Math.atan2(c[2], c[1])));\n    return _Color.lch(\n      c[0],\n      Math.sqrt(c[1] * c[1] + c[2] * c[2]),\n      h,\n      lab.alpha\n    );\n  }\n  static LCHtoLAB(lch, normalizedInput = false, normalizedOutput = false) {\n    let c = normalizedInput ? lch.$normalize(false) : lch;\n    let rad = Geom.toRadian(c[2]);\n    return _Color.lab(\n      c[0],\n      Math.cos(rad) * c[1],\n      Math.sin(rad) * c[1],\n      lch.alpha\n    );\n  }\n};\nvar Color = _Color;\nColor.D65 = new Pt(95.047, 100, 108.883, 1);\nColor.ranges = {\n  rgb: new Group(new Pt(0, 255), new Pt(0, 255), new Pt(0, 255)),\n  hsl: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n  hsb: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n  lab: new Group(new Pt(0, 100), new Pt(-128, 127), new Pt(-128, 127)),\n  lch: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 360)),\n  luv: new Group(new Pt(0, 100), new Pt(-134, 220), new Pt(-140, 122)),\n  xyz: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 100))\n};\n\n// src/Dom.ts\nvar DOMSpace = class extends MultiTouchSpace {\n  constructor(elem, callback) {\n    super();\n    this.id = \"domspace\";\n    this._autoResize = true;\n    this._bgcolor = \"#e1e9f0\";\n    this._css = {};\n    var _selector = null;\n    var _existed = false;\n    this.id = \"pts\";\n    if (elem instanceof Element) {\n      _selector = elem;\n      this.id = \"pts_existing_space\";\n    } else {\n      _selector = document.querySelector(elem);\n      _existed = true;\n      this.id = elem.substr(1);\n    }\n    if (!_selector) {\n      this._container = DOMSpace.createElement(\"div\", \"pts_container\");\n      this._canvas = DOMSpace.createElement(\"div\", \"pts_element\");\n      this._container.appendChild(this._canvas);\n      document.body.appendChild(this._container);\n      _existed = false;\n    } else {\n      this._canvas = _selector;\n      this._container = _selector.parentElement;\n    }\n    setTimeout(this._ready.bind(this, callback), 50);\n  }\n  static createElement(elem = \"div\", id, appendTo) {\n    let d = document.createElement(elem);\n    if (id)\n      d.setAttribute(\"id\", id);\n    if (appendTo && appendTo.appendChild)\n      appendTo.appendChild(d);\n    return d;\n  }\n  _ready(callback) {\n    if (!this._container)\n      throw new Error(`Cannot initiate #${this.id} element`);\n    this._isReady = true;\n    this._resizeHandler(null);\n    this.clear(this._bgcolor);\n    this._canvas.dispatchEvent(new Event(\"ready\"));\n    for (let k in this.players) {\n      if (this.players.hasOwnProperty(k)) {\n        if (this.players[k].start)\n          this.players[k].start(this.bound.clone(), this);\n      }\n    }\n    this._pointer = this.center;\n    this.refresh(false);\n    if (callback)\n      callback(this.bound, this._canvas);\n  }\n  setup(opt) {\n    if (opt.bgcolor) {\n      this._bgcolor = opt.bgcolor;\n    }\n    this.autoResize = opt.resize != void 0 ? opt.resize : false;\n    return this;\n  }\n  getForm() {\n    return null;\n  }\n  set autoResize(auto) {\n    this._autoResize = auto;\n    if (auto) {\n      window.addEventListener(\"resize\", this._resizeHandler.bind(this));\n    } else {\n      delete this._css[\"width\"];\n      delete this._css[\"height\"];\n      window.removeEventListener(\"resize\", this._resizeHandler.bind(this));\n    }\n  }\n  get autoResize() {\n    return this._autoResize;\n  }\n  resize(b, evt) {\n    this.bound = b;\n    this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n    for (let k in this.players) {\n      if (this.players.hasOwnProperty(k)) {\n        let p = this.players[k];\n        if (p.resize)\n          p.resize(this.bound, evt);\n      }\n    }\n    return this;\n  }\n  _resizeHandler(evt) {\n    let b = Bound.fromBoundingRect(this._container.getBoundingClientRect());\n    if (this._autoResize) {\n      this.styles({ width: \"100%\", height: \"100%\" }, true);\n    } else {\n      this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n    }\n    this.resize(b, evt);\n  }\n  get element() {\n    return this._canvas;\n  }\n  get parent() {\n    return this._container;\n  }\n  get ready() {\n    return this._isReady;\n  }\n  clear(bg) {\n    if (bg)\n      this.background = bg;\n    this._canvas.innerHTML = \"\";\n    return this;\n  }\n  set background(bg) {\n    this._bgcolor = bg;\n    this._container.style.backgroundColor = this._bgcolor;\n  }\n  get background() {\n    return this._bgcolor;\n  }\n  style(key, val, update = false) {\n    this._css[key] = val;\n    if (update)\n      this._canvas.style[key] = val;\n    return this;\n  }\n  styles(styles, update = false) {\n    for (let k in styles) {\n      if (styles.hasOwnProperty(k))\n        this.style(k, styles[k], update);\n    }\n    return this;\n  }\n  static setAttr(elem, data) {\n    for (let k in data) {\n      if (data.hasOwnProperty(k)) {\n        elem.setAttribute(k, data[k]);\n      }\n    }\n    return elem;\n  }\n  static getInlineStyles(data) {\n    let str = \"\";\n    for (let k in data) {\n      if (data.hasOwnProperty(k)) {\n        if (data[k])\n          str += `${k}: ${data[k]}; `;\n      }\n    }\n    return str;\n  }\n  dispose() {\n    window.removeEventListener(\"resize\", this._resizeHandler.bind(this));\n    this.stop();\n    this.removeAll();\n    return this;\n  }\n};\nvar HTMLSpace = class extends DOMSpace {\n  getForm() {\n    return new HTMLForm(this);\n  }\n  static htmlElement(parent, name, id, autoClass = true) {\n    if (!parent || !parent.appendChild)\n      throw new Error(\"parent is not a valid DOM element\");\n    let elem = document.querySelector(`#${id}`);\n    if (!elem) {\n      elem = document.createElement(name);\n      elem.setAttribute(\"id\", id);\n      if (autoClass)\n        elem.setAttribute(\"class\", id.substring(0, id.indexOf(\"-\")));\n      parent.appendChild(elem);\n    }\n    return elem;\n  }\n  remove(player) {\n    let temp = this._container.querySelectorAll(\".\" + HTMLForm.scopeID(player));\n    temp.forEach((el) => {\n      el.parentNode.removeChild(el);\n    });\n    return super.remove(player);\n  }\n  removeAll() {\n    this._container.innerHTML = \"\";\n    return super.removeAll();\n  }\n};\nvar _HTMLForm = class extends VisualForm {\n  constructor(space) {\n    super();\n    this._style = {\n      \"filled\": true,\n      \"stroked\": true,\n      \"background\": \"#f03\",\n      \"border-color\": \"#fff\",\n      \"color\": \"#000\",\n      \"border-width\": \"1px\",\n      \"border-radius\": \"0\",\n      \"border-style\": \"solid\",\n      \"opacity\": 1,\n      \"position\": \"absolute\",\n      \"top\": 0,\n      \"left\": 0,\n      \"width\": 0,\n      \"height\": 0\n    };\n    this._ctx = {\n      group: null,\n      groupID: \"pts\",\n      groupCount: 0,\n      currentID: \"pts0\",\n      currentClass: \"\",\n      style: {}\n    };\n    this._ready = false;\n    this._space = space;\n    this._space.add({ start: () => {\n      this._ctx.group = this._space.element;\n      this._ctx.groupID = \"pts_dom_\" + _HTMLForm.groupID++;\n      this._ctx.style = Object.assign({}, this._style);\n      this._ready = true;\n    } });\n  }\n  get space() {\n    return this._space;\n  }\n  styleTo(k, v, unit = \"\") {\n    if (this._ctx.style[k] === void 0)\n      throw new Error(`${k} style property doesn't exist`);\n    this._ctx.style[k] = `${v}${unit}`;\n  }\n  alpha(a) {\n    this.styleTo(\"opacity\", a);\n    return this;\n  }\n  fill(c) {\n    if (typeof c == \"boolean\") {\n      this.styleTo(\"filled\", c);\n      if (!c)\n        this.styleTo(\"background\", \"transparent\");\n    } else {\n      this.styleTo(\"filled\", true);\n      this.styleTo(\"background\", c);\n    }\n    return this;\n  }\n  stroke(c, width, linejoin, linecap) {\n    if (typeof c == \"boolean\") {\n      this.styleTo(\"stroked\", c);\n      if (!c)\n        this.styleTo(\"border-width\", 0);\n    } else {\n      this.styleTo(\"stroked\", true);\n      this.styleTo(\"border-color\", c);\n      this.styleTo(\"border-width\", (width || 1) + \"px\");\n    }\n    return this;\n  }\n  fillText(c) {\n    this.styleTo(\"color\", c);\n    return this;\n  }\n  cls(c) {\n    if (typeof c == \"boolean\") {\n      this._ctx.currentClass = \"\";\n    } else {\n      this._ctx.currentClass = c;\n    }\n    return this;\n  }\n  font(sizeOrFont, weight, style, lineHeight, family) {\n    if (typeof sizeOrFont == \"number\") {\n      this._font.size = sizeOrFont;\n      if (family)\n        this._font.face = family;\n      if (weight)\n        this._font.weight = weight;\n      if (style)\n        this._font.style = style;\n      if (lineHeight)\n        this._font.lineHeight = lineHeight;\n    } else {\n      this._font = sizeOrFont;\n    }\n    this._ctx.style[\"font\"] = this._font.value;\n    return this;\n  }\n  reset() {\n    this._ctx.style = Object.assign({}, this._style);\n    this._font = new Font(10, \"sans-serif\");\n    this._ctx.style[\"font\"] = this._font.value;\n    return this;\n  }\n  updateScope(group_id, group) {\n    this._ctx.group = group;\n    this._ctx.groupID = group_id;\n    this._ctx.groupCount = 0;\n    this.nextID();\n    return this._ctx;\n  }\n  scope(item) {\n    if (!item || item.animateID == null)\n      throw new Error(\"item not defined or not yet added to Space\");\n    return this.updateScope(_HTMLForm.scopeID(item), this.space.element);\n  }\n  nextID() {\n    this._ctx.groupCount++;\n    this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n    return this._ctx.currentID;\n  }\n  static getID(ctx) {\n    return ctx.currentID || `p-${_HTMLForm.domID++}`;\n  }\n  static scopeID(item) {\n    return `item-${item.animateID}`;\n  }\n  static style(elem, styles) {\n    let st = [];\n    if (!styles[\"filled\"])\n      st.push(\"background: none\");\n    if (!styles[\"stroked\"])\n      st.push(\"border: none\");\n    for (let k in styles) {\n      if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n        let v = styles[k];\n        if (v) {\n          if (!styles[\"filled\"] && k.indexOf(\"background\") === 0) {\n            continue;\n          } else if (!styles[\"stroked\"] && k.indexOf(\"border-width\") === 0) {\n            continue;\n          } else {\n            st.push(`${k}: ${v}`);\n          }\n        }\n      }\n    }\n    return HTMLSpace.setAttr(elem, { style: st.join(\";\") });\n  }\n  static rectStyle(ctx, pt, size) {\n    ctx.style[\"left\"] = pt[0] + \"px\";\n    ctx.style[\"top\"] = pt[1] + \"px\";\n    ctx.style[\"width\"] = size[0] + \"px\";\n    ctx.style[\"height\"] = size[1] + \"px\";\n    return ctx;\n  }\n  static textStyle(ctx, pt) {\n    ctx.style[\"left\"] = pt[0] + \"px\";\n    ctx.style[\"top\"] = pt[1] + \"px\";\n    return ctx;\n  }\n  static point(ctx, pt, radius = 5, shape = \"square\") {\n    if (shape === \"circle\") {\n      return _HTMLForm.circle(ctx, pt, radius);\n    } else {\n      return _HTMLForm.square(ctx, pt, radius);\n    }\n  }\n  point(pt, radius = 5, shape = \"square\") {\n    this.nextID();\n    if (shape == \"circle\")\n      this.styleTo(\"border-radius\", \"100%\");\n    _HTMLForm.point(this._ctx, pt, radius, shape);\n    return this;\n  }\n  static circle(ctx, pt, radius = 10) {\n    let elem = HTMLSpace.htmlElement(ctx.group, \"div\", _HTMLForm.getID(ctx));\n    HTMLSpace.setAttr(elem, { class: `pts-form pts-circle ${ctx.currentClass}` });\n    _HTMLForm.rectStyle(ctx, new Pt(pt).$subtract(radius), new Pt(radius * 2, radius * 2));\n    _HTMLForm.style(elem, ctx.style);\n    return elem;\n  }\n  circle(pts) {\n    this.nextID();\n    this.styleTo(\"border-radius\", \"100%\");\n    _HTMLForm.circle(this._ctx, pts[0], pts[1][0]);\n    return this;\n  }\n  static square(ctx, pt, halfsize) {\n    let elem = HTMLSpace.htmlElement(ctx.group, \"div\", _HTMLForm.getID(ctx));\n    HTMLSpace.setAttr(elem, { class: `pts-form pts-square ${ctx.currentClass}` });\n    _HTMLForm.rectStyle(ctx, new Pt(pt).$subtract(halfsize), new Pt(halfsize * 2, halfsize * 2));\n    _HTMLForm.style(elem, ctx.style);\n    return elem;\n  }\n  square(pt, halfsize) {\n    this.nextID();\n    _HTMLForm.square(this._ctx, pt, halfsize);\n    return this;\n  }\n  static rect(ctx, pts) {\n    let p = Util.iterToArray(pts);\n    if (!Util.arrayCheck(p))\n      return;\n    let elem = HTMLSpace.htmlElement(ctx.group, \"div\", _HTMLForm.getID(ctx));\n    HTMLSpace.setAttr(elem, { class: `pts-form pts-rect ${ctx.currentClass}` });\n    _HTMLForm.rectStyle(ctx, p[0], p[1]);\n    _HTMLForm.style(elem, ctx.style);\n    return elem;\n  }\n  rect(pts) {\n    this.nextID();\n    this.styleTo(\"border-radius\", \"0\");\n    _HTMLForm.rect(this._ctx, pts);\n    return this;\n  }\n  static text(ctx, pt, txt) {\n    let elem = HTMLSpace.htmlElement(ctx.group, \"div\", _HTMLForm.getID(ctx));\n    HTMLSpace.setAttr(elem, { class: `pts-form pts-text ${ctx.currentClass}` });\n    elem.textContent = txt;\n    _HTMLForm.textStyle(ctx, pt);\n    _HTMLForm.style(elem, ctx.style);\n    return elem;\n  }\n  text(pt, txt) {\n    this.nextID();\n    _HTMLForm.text(this._ctx, pt, txt);\n    return this;\n  }\n  log(txt) {\n    this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n    return this;\n  }\n  arc(pt, radius, startAngle, endAngle, cc) {\n    Util.warn(\"arc is not implemented in HTMLForm\");\n    return this;\n  }\n  line(pts) {\n    Util.warn(\"line is not implemented in HTMLForm\");\n    return this;\n  }\n  polygon(pts) {\n    Util.warn(\"polygon is not implemented in HTMLForm\");\n    return this;\n  }\n};\nvar HTMLForm = _HTMLForm;\nHTMLForm.groupID = 0;\nHTMLForm.domID = 0;\n\n// src/Svg.ts\nvar SVGSpace = class extends DOMSpace {\n  constructor(elem, callback) {\n    super(elem, callback);\n    this._bgcolor = \"#999\";\n    if (this._canvas.nodeName.toLowerCase() != \"svg\") {\n      let s = SVGSpace.svgElement(this._canvas, \"svg\", `${this.id}_svg`);\n      this._container = this._canvas;\n      this._canvas = s;\n    }\n  }\n  getForm() {\n    return new SVGForm(this);\n  }\n  get element() {\n    return this._canvas;\n  }\n  resize(b, evt) {\n    super.resize(b, evt);\n    SVGSpace.setAttr(this.element, {\n      \"viewBox\": `0 0 ${this.bound.width} ${this.bound.height}`,\n      \"width\": `${this.bound.width}`,\n      \"height\": `${this.bound.height}`,\n      \"xmlns\": \"http://www.w3.org/2000/svg\",\n      \"version\": \"1.1\"\n    });\n    return this;\n  }\n  static svgElement(parent, name, id) {\n    if (!parent || !parent.appendChild)\n      throw new Error(\"parent is not a valid DOM element\");\n    let elem = document.querySelector(`#${id}`);\n    if (!elem) {\n      elem = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n      elem.setAttribute(\"id\", id);\n      parent.appendChild(elem);\n    }\n    return elem;\n  }\n  remove(player) {\n    let temp = this._container.querySelectorAll(\".\" + SVGForm.scopeID(player));\n    temp.forEach((el) => {\n      el.parentNode.removeChild(el);\n    });\n    return super.remove(player);\n  }\n  removeAll() {\n    this._container.innerHTML = \"\";\n    return super.removeAll();\n  }\n};\nvar _SVGForm = class extends VisualForm {\n  constructor(space) {\n    super();\n    this._style = {\n      \"filled\": true,\n      \"stroked\": true,\n      \"fill\": \"#f03\",\n      \"stroke\": \"#fff\",\n      \"stroke-width\": 1,\n      \"stroke-linejoin\": \"bevel\",\n      \"stroke-linecap\": \"sqaure\",\n      \"opacity\": 1\n    };\n    this._ctx = {\n      group: null,\n      groupID: \"pts\",\n      groupCount: 0,\n      currentID: \"pts0\",\n      currentClass: \"\",\n      style: {}\n    };\n    this._ready = false;\n    this._space = space;\n    this._space.add({ start: () => {\n      this._ctx.group = this._space.element;\n      this._ctx.groupID = \"pts_svg_\" + _SVGForm.groupID++;\n      this._ctx.style = Object.assign({}, this._style);\n      this._ready = true;\n    } });\n  }\n  get space() {\n    return this._space;\n  }\n  styleTo(k, v) {\n    if (this._ctx.style[k] === void 0)\n      throw new Error(`${k} style property doesn't exist`);\n    this._ctx.style[k] = v;\n  }\n  alpha(a) {\n    this.styleTo(\"opacity\", a);\n    return this;\n  }\n  fill(c) {\n    if (typeof c == \"boolean\") {\n      this.styleTo(\"filled\", c);\n    } else {\n      this.styleTo(\"filled\", true);\n      this.styleTo(\"fill\", c);\n    }\n    return this;\n  }\n  stroke(c, width, linejoin, linecap) {\n    if (typeof c == \"boolean\") {\n      this.styleTo(\"stroked\", c);\n    } else {\n      this.styleTo(\"stroked\", true);\n      this.styleTo(\"stroke\", c);\n      if (width)\n        this.styleTo(\"stroke-width\", width);\n      if (linejoin)\n        this.styleTo(\"stroke-linejoin\", linejoin);\n      if (linecap)\n        this.styleTo(\"stroke-linecap\", linecap);\n    }\n    return this;\n  }\n  cls(c) {\n    if (typeof c == \"boolean\") {\n      this._ctx.currentClass = \"\";\n    } else {\n      this._ctx.currentClass = c;\n    }\n    return this;\n  }\n  font(sizeOrFont, weight, style, lineHeight, family) {\n    if (typeof sizeOrFont == \"number\") {\n      this._font.size = sizeOrFont;\n      if (family)\n        this._font.face = family;\n      if (weight)\n        this._font.weight = weight;\n      if (style)\n        this._font.style = style;\n      if (lineHeight)\n        this._font.lineHeight = lineHeight;\n    } else {\n      this._font = sizeOrFont;\n    }\n    this._ctx.style[\"font\"] = this._font.value;\n    return this;\n  }\n  reset() {\n    this._ctx.style = Object.assign({}, this._style);\n    this._font = new Font(10, \"sans-serif\");\n    this._ctx.style[\"font\"] = this._font.value;\n    return this;\n  }\n  updateScope(group_id, group) {\n    this._ctx.group = group;\n    this._ctx.groupID = group_id;\n    this._ctx.groupCount = 0;\n    this.nextID();\n    return this._ctx;\n  }\n  scope(item) {\n    if (!item || item.animateID == null)\n      throw new Error(\"item not defined or not yet added to Space\");\n    return this.updateScope(_SVGForm.scopeID(item), this.space.element);\n  }\n  nextID() {\n    this._ctx.groupCount++;\n    this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n    return this._ctx.currentID;\n  }\n  static getID(ctx) {\n    return ctx.currentID || `p-${_SVGForm.domID++}`;\n  }\n  static scopeID(item) {\n    return `item-${item.animateID}`;\n  }\n  static style(elem, styles) {\n    let st = [];\n    if (!styles[\"filled\"])\n      st.push(\"fill: none\");\n    if (!styles[\"stroked\"])\n      st.push(\"stroke: none\");\n    for (let k in styles) {\n      if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n        let v = styles[k];\n        if (v) {\n          if (!styles[\"filled\"] && k.indexOf(\"fill\") === 0) {\n            continue;\n          } else if (!styles[\"stroked\"] && k.indexOf(\"stroke\") === 0) {\n            continue;\n          } else {\n            st.push(`${k}: ${v}`);\n          }\n        }\n      }\n    }\n    return DOMSpace.setAttr(elem, { style: st.join(\";\") });\n  }\n  static point(ctx, pt, radius = 5, shape = \"square\") {\n    if (shape === \"circle\") {\n      return _SVGForm.circle(ctx, pt, radius);\n    } else {\n      return _SVGForm.square(ctx, pt, radius);\n    }\n  }\n  point(pt, radius = 5, shape = \"square\") {\n    this.nextID();\n    _SVGForm.point(this._ctx, pt, radius, shape);\n    return this;\n  }\n  static circle(ctx, pt, radius = 10) {\n    let elem = SVGSpace.svgElement(ctx.group, \"circle\", _SVGForm.getID(ctx));\n    DOMSpace.setAttr(elem, {\n      cx: pt[0],\n      cy: pt[1],\n      r: radius,\n      \"class\": `pts-svgform pts-circle ${ctx.currentClass}`\n    });\n    _SVGForm.style(elem, ctx.style);\n    return elem;\n  }\n  circle(pts) {\n    this.nextID();\n    let p = Util.iterToArray(pts);\n    _SVGForm.circle(this._ctx, p[0], p[1][0]);\n    return this;\n  }\n  static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n    let elem = SVGSpace.svgElement(ctx.group, \"path\", _SVGForm.getID(ctx));\n    const start = new Pt(pt).toAngle(startAngle, radius, true);\n    const end = new Pt(pt).toAngle(endAngle, radius, true);\n    const diff = Geom.boundAngle(endAngle) - Geom.boundAngle(startAngle);\n    let largeArc = diff > Const.pi ? true : false;\n    if (cc)\n      largeArc = !largeArc;\n    const sweep = cc ? \"0\" : \"1\";\n    const d = `M ${start[0]} ${start[1]} A ${radius} ${radius} 0 ${largeArc ? \"1\" : \"0\"} ${sweep} ${end[0]} ${end[1]}`;\n    DOMSpace.setAttr(elem, {\n      d,\n      \"class\": `pts-svgform pts-arc ${ctx.currentClass}`\n    });\n    _SVGForm.style(elem, ctx.style);\n    return elem;\n  }\n  arc(pt, radius, startAngle, endAngle, cc) {\n    this.nextID();\n    _SVGForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n    return this;\n  }\n  static square(ctx, pt, halfsize) {\n    let elem = SVGSpace.svgElement(ctx.group, \"rect\", _SVGForm.getID(ctx));\n    DOMSpace.setAttr(elem, {\n      x: pt[0] - halfsize,\n      y: pt[1] - halfsize,\n      width: halfsize * 2,\n      height: halfsize * 2,\n      \"class\": `pts-svgform pts-square ${ctx.currentClass}`\n    });\n    _SVGForm.style(elem, ctx.style);\n    return elem;\n  }\n  square(pt, halfsize) {\n    this.nextID();\n    _SVGForm.square(this._ctx, pt, halfsize);\n    return this;\n  }\n  static line(ctx, pts) {\n    let points = _SVGForm.pointsString(pts);\n    if (points.count < 2)\n      return;\n    if (points.count > 2)\n      return _SVGForm._poly(ctx, points.string, false);\n    let elem = SVGSpace.svgElement(ctx.group, \"line\", _SVGForm.getID(ctx));\n    let p = Util.iterToArray(pts);\n    DOMSpace.setAttr(elem, {\n      x1: p[0][0],\n      y1: p[0][1],\n      x2: p[1][0],\n      y2: p[1][1],\n      \"class\": `pts-svgform pts-line ${ctx.currentClass}`\n    });\n    _SVGForm.style(elem, ctx.style);\n    return elem;\n  }\n  line(pts) {\n    this.nextID();\n    _SVGForm.line(this._ctx, pts);\n    return this;\n  }\n  static _poly(ctx, points, closePath = true) {\n    let elem = SVGSpace.svgElement(ctx.group, closePath ? \"polygon\" : \"polyline\", _SVGForm.getID(ctx));\n    DOMSpace.setAttr(elem, {\n      points,\n      \"class\": `pts-svgform pts-polygon ${ctx.currentClass}`\n    });\n    _SVGForm.style(elem, ctx.style);\n    return elem;\n  }\n  static pointsString(pts) {\n    let points = \"\";\n    let count = 0;\n    for (let p of pts) {\n      points += `${p[0]},${p[1]} `;\n      count++;\n    }\n    return { string: points, count };\n  }\n  static polygon(ctx, pts) {\n    let points = _SVGForm.pointsString(pts);\n    return _SVGForm._poly(ctx, points.string, true);\n  }\n  polygon(pts) {\n    this.nextID();\n    _SVGForm.polygon(this._ctx, pts);\n    return this;\n  }\n  static rect(ctx, pts) {\n    if (!Util.arrayCheck(pts))\n      return;\n    let elem = SVGSpace.svgElement(ctx.group, \"rect\", _SVGForm.getID(ctx));\n    let bound = Group.fromArray(pts).boundingBox();\n    let size = Rectangle.size(bound);\n    DOMSpace.setAttr(elem, {\n      x: bound[0][0],\n      y: bound[0][1],\n      width: size[0],\n      height: size[1],\n      \"class\": `pts-svgform pts-rect ${ctx.currentClass}`\n    });\n    _SVGForm.style(elem, ctx.style);\n    return elem;\n  }\n  rect(pts) {\n    this.nextID();\n    _SVGForm.rect(this._ctx, pts);\n    return this;\n  }\n  static text(ctx, pt, txt) {\n    let elem = SVGSpace.svgElement(ctx.group, \"text\", _SVGForm.getID(ctx));\n    DOMSpace.setAttr(elem, {\n      \"pointer-events\": \"none\",\n      x: pt[0],\n      y: pt[1],\n      dx: 0,\n      dy: 0,\n      \"class\": `pts-svgform pts-text ${ctx.currentClass}`\n    });\n    elem.textContent = txt;\n    _SVGForm.style(elem, ctx.style);\n    return elem;\n  }\n  text(pt, txt) {\n    this.nextID();\n    _SVGForm.text(this._ctx, pt, txt);\n    return this;\n  }\n  log(txt) {\n    this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n    return this;\n  }\n};\nvar SVGForm = _SVGForm;\nSVGForm.groupID = 0;\nSVGForm.domID = 0;\n\n// src/Physics.ts\nvar World = class {\n  constructor(bound, friction = 1, gravity = 0) {\n    this._lastTime = null;\n    this._gravity = new Pt();\n    this._friction = 1;\n    this._damping = 0.75;\n    this._particles = [];\n    this._bodies = [];\n    this._pnames = [];\n    this._bnames = [];\n    this._bound = Bound.fromGroup(bound);\n    this._friction = friction;\n    this._gravity = typeof gravity === \"number\" ? new Pt(0, gravity) : new Pt(gravity);\n    return this;\n  }\n  get bound() {\n    return this._bound;\n  }\n  set bound(bound) {\n    this._bound = bound;\n  }\n  get gravity() {\n    return this._gravity;\n  }\n  set gravity(g) {\n    this._gravity = g;\n  }\n  get friction() {\n    return this._friction;\n  }\n  set friction(f) {\n    this._friction = f;\n  }\n  get damping() {\n    return this._damping;\n  }\n  set damping(f) {\n    this._damping = f;\n  }\n  get bodyCount() {\n    return this._bodies.length;\n  }\n  get particleCount() {\n    return this._particles.length;\n  }\n  body(id) {\n    let idx = id;\n    if (typeof id === \"string\" && id.length > 0) {\n      idx = this._bnames.indexOf(id);\n    }\n    if (!(idx >= 0))\n      return void 0;\n    return this._bodies[idx];\n  }\n  particle(id) {\n    let idx = id;\n    if (typeof id === \"string\" && id.length > 0) {\n      idx = this._pnames.indexOf(id);\n    }\n    if (!(idx >= 0))\n      return void 0;\n    return this._particles[idx];\n  }\n  bodyIndex(name) {\n    return this._bnames.indexOf(name);\n  }\n  particleIndex(name) {\n    return this._pnames.indexOf(name);\n  }\n  update(ms) {\n    let dt = ms / 1e3;\n    this._updateParticles(dt);\n    this._updateBodies(dt);\n  }\n  drawParticles(fn) {\n    this._drawParticles = fn;\n  }\n  drawBodies(fn) {\n    this._drawBodies = fn;\n  }\n  add(p, name = \"\") {\n    if (p instanceof Body) {\n      this._bodies.push(p);\n      this._bnames.push(name);\n    } else {\n      this._particles.push(p);\n      this._pnames.push(name);\n    }\n    return this;\n  }\n  _index(fn, id) {\n    let index = 0;\n    if (typeof id === \"string\") {\n      index = fn(id);\n      if (index < 0)\n        throw new Error(`Cannot find index of ${id}. You can use particleIndex() or bodyIndex() function to check existence by name.`);\n    } else {\n      index = id;\n    }\n    return index;\n  }\n  removeBody(from, count = 1) {\n    const index = this._index(this.bodyIndex.bind(this), from);\n    const param = index < 0 ? [index * -1 - 1, count] : [index, count];\n    this._bodies.splice(param[0], param[1]);\n    this._bnames.splice(param[0], param[1]);\n    return this;\n  }\n  removeParticle(from, count = 1) {\n    const index = this._index(this.particleIndex.bind(this), from);\n    const param = index < 0 ? [index * -1 - 1, count] : [index, count];\n    this._particles.splice(param[0], param[1]);\n    this._pnames.splice(param[0], param[1]);\n    return this;\n  }\n  static edgeConstraint(p1, p2, dist, stiff = 1, precise = false) {\n    const m1 = 1 / (p1.mass || 1);\n    const m2 = 1 / (p2.mass || 1);\n    const mm = m1 + m2;\n    let delta = p2.$subtract(p1);\n    let distSq = dist * dist;\n    let d = precise ? dist / delta.magnitude() - 1 : distSq / (delta.dot(delta) + distSq) - 0.5;\n    let f = delta.$multiply(d * stiff);\n    p1.subtract(f.$multiply(m1 / mm));\n    p2.add(f.$multiply(m2 / mm));\n    return p1;\n  }\n  static boundConstraint(p, rect, damping = 0.75) {\n    let bound = Geom.boundingBox(rect);\n    let np = p.$min(bound[1].subtract(p.radius)).$max(bound[0].add(p.radius));\n    if (np[0] === bound[0][0] || np[0] === bound[1][0]) {\n      let c = p.changed.$multiply(damping);\n      p.previous = np.$subtract(new Pt(-c[0], c[1]));\n    } else if (np[1] === bound[0][1] || np[1] === bound[1][1]) {\n      let c = p.changed.$multiply(damping);\n      p.previous = np.$subtract(new Pt(c[0], -c[1]));\n    }\n    p.to(np);\n  }\n  integrate(p, dt, prevDt) {\n    p.addForce(this._gravity);\n    p.verlet(dt, this._friction, prevDt);\n    return p;\n  }\n  _updateParticles(dt) {\n    for (let i = 0, len = this._particles.length; i < len; i++) {\n      let p = this._particles[i];\n      this.integrate(p, dt, this._lastTime);\n      World.boundConstraint(p, this._bound, this._damping);\n      for (let k = i + 1; k < len; k++) {\n        if (i !== k) {\n          let p2 = this._particles[k];\n          p.collide(p2, this._damping);\n        }\n      }\n      if (this._drawParticles)\n        this._drawParticles(p, i);\n    }\n    this._lastTime = dt;\n  }\n  _updateBodies(dt) {\n    for (let i = 0, len = this._bodies.length; i < len; i++) {\n      let bds = this._bodies[i];\n      if (bds) {\n        for (let k = 0, klen = bds.length; k < klen; k++) {\n          let bk = bds[k];\n          World.boundConstraint(bk, this._bound, this._damping);\n          this.integrate(bk, dt, this._lastTime);\n        }\n        for (let k = i + 1; k < len; k++) {\n          bds.processBody(this._bodies[k]);\n        }\n        for (let m = 0, mlen = this._particles.length; m < mlen; m++) {\n          bds.processParticle(this._particles[m]);\n        }\n        bds.processEdges();\n        if (this._drawBodies)\n          this._drawBodies(bds, i);\n      }\n    }\n  }\n};\nvar Particle = class extends Pt {\n  constructor(...args) {\n    super(...args);\n    this._mass = 1;\n    this._radius = 0;\n    this._force = new Pt();\n    this._prev = new Pt();\n    this._lock = false;\n    this._prev = this.clone();\n  }\n  get mass() {\n    return this._mass;\n  }\n  set mass(m) {\n    this._mass = m;\n  }\n  get radius() {\n    return this._radius;\n  }\n  set radius(f) {\n    this._radius = f;\n  }\n  get previous() {\n    return this._prev;\n  }\n  set previous(p) {\n    this._prev = p;\n  }\n  get force() {\n    return this._force;\n  }\n  set force(g) {\n    this._force = g;\n  }\n  get body() {\n    return this._body;\n  }\n  set body(b) {\n    this._body = b;\n  }\n  get lock() {\n    return this._lock;\n  }\n  set lock(b) {\n    this._lock = b;\n    this._lockPt = new Pt(this);\n  }\n  get changed() {\n    return this.$subtract(this._prev);\n  }\n  set position(p) {\n    this.previous.to(this);\n    if (this._lock)\n      this._lockPt = p;\n    this.to(p);\n  }\n  size(r) {\n    this._mass = r;\n    this._radius = r;\n    return this;\n  }\n  addForce(...args) {\n    this._force.add(...args);\n    return this._force;\n  }\n  verlet(dt, friction, lastDt) {\n    if (this._lock) {\n      this.to(this._lockPt);\n    } else {\n      let lt = lastDt ? lastDt : dt;\n      let a = this._force.multiply(dt * (dt + lt) / 2);\n      let v = this.changed.multiply(friction * dt / lt).add(a);\n      this._prev = this.clone();\n      this.add(v);\n      this._force = new Pt();\n    }\n    return this;\n  }\n  hit(...args) {\n    this._prev.subtract(new Pt(...args).$divide(Math.sqrt(this._mass)));\n    return this;\n  }\n  collide(p2, damp = 1) {\n    let p1 = this;\n    let dp = p1.$subtract(p2);\n    let distSq = dp.magnitudeSq();\n    let dr = p1.radius + p2.radius;\n    if (distSq < dr * dr) {\n      let c1 = p1.changed;\n      let c2 = p2.changed;\n      let dist = Math.sqrt(distSq);\n      let d = dp.$multiply((dist - dr) / dist / 2);\n      let np1 = p1.$subtract(d);\n      let np2 = p2.$add(d);\n      p1.to(np1);\n      p2.to(np2);\n      let f1 = damp * dp.dot(c1) / distSq;\n      let f2 = damp * dp.dot(c2) / distSq;\n      let dm1 = p1.mass / (p1.mass + p2.mass);\n      let dm2 = p2.mass / (p1.mass + p2.mass);\n      c1.add(new Pt(f2 * dp[0] - f1 * dp[0], f2 * dp[1] - f1 * dp[1]).$multiply(dm2));\n      c2.add(new Pt(f1 * dp[0] - f2 * dp[0], f1 * dp[1] - f2 * dp[1]).$multiply(dm1));\n      p1.previous = p1.$subtract(c1);\n      p2.previous = p2.$subtract(c2);\n    }\n  }\n  toString() {\n    return `Particle: ${this[0]} ${this[1]} | previous ${this._prev[0]} ${this._prev[1]} | mass ${this._mass}`;\n  }\n};\nvar Body = class extends Group {\n  constructor() {\n    super();\n    this._cs = [];\n    this._stiff = 1;\n    this._locks = {};\n    this._mass = 1;\n  }\n  static fromGroup(body, stiff = 1, autoLink = true, autoMass = true) {\n    let b = new Body().init(body);\n    if (autoLink)\n      b.linkAll(stiff);\n    if (autoMass)\n      b.autoMass();\n    return b;\n  }\n  init(body, stiff = 1) {\n    let c = new Pt();\n    for (let li of body) {\n      let p = new Particle(li);\n      p.body = this;\n      c.add(li);\n      this.push(p);\n    }\n    this._stiff = stiff;\n    return this;\n  }\n  get mass() {\n    return this._mass;\n  }\n  set mass(m) {\n    this._mass = m;\n    for (let i = 0, len = this.length; i < len; i++) {\n      this[i].mass = this._mass;\n    }\n  }\n  autoMass() {\n    this.mass = Math.sqrt(Polygon.area(this)) / 10;\n    return this;\n  }\n  link(index1, index2, stiff) {\n    if (index1 < 0 || index1 >= this.length)\n      throw new Error(\"index1 is not in the Group's indices\");\n    if (index2 < 0 || index2 >= this.length)\n      throw new Error(\"index1 is not in the Group's indices\");\n    let d = this[index1].$subtract(this[index2]).magnitude();\n    this._cs.push([index1, index2, d, stiff || this._stiff]);\n    return this;\n  }\n  linkAll(stiff) {\n    let half = this.length / 2;\n    for (let i = 0, len = this.length; i < len; i++) {\n      let n = i >= len - 1 ? 0 : i + 1;\n      this.link(i, n, stiff);\n      if (len > 4) {\n        let nd = Math.floor(half / 2) + 1;\n        let n2 = i >= len - nd ? i % len : i + nd;\n        this.link(i, n2, stiff);\n      }\n      if (i <= half - 1) {\n        this.link(i, Math.min(this.length - 1, i + Math.floor(half)));\n      }\n    }\n  }\n  linksToLines() {\n    let gs = [];\n    for (let i = 0, len = this._cs.length; i < len; i++) {\n      let ln = this._cs[i];\n      gs.push(new Group(this[ln[0]], this[ln[1]]));\n    }\n    return gs;\n  }\n  processEdges() {\n    for (let i = 0, len = this._cs.length; i < len; i++) {\n      let [m, n, d, s] = this._cs[i];\n      World.edgeConstraint(this[m], this[n], d, s);\n    }\n  }\n  processBody(b) {\n    let b1 = this;\n    let b2 = b;\n    let hit = Polygon.hasIntersectPolygon(b1, b2);\n    if (hit) {\n      let cv = hit.normal.$multiply(hit.dist);\n      let t;\n      let eg = hit.edge;\n      if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n        t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n      } else {\n        t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n      }\n      let lambda = 1 / (t * t + (1 - t) * (1 - t));\n      let m0 = hit.vertex.body.mass || 1;\n      let m1 = hit.edge[0].body.mass || 1;\n      let mr0 = m0 / (m0 + m1);\n      let mr1 = m1 / (m0 + m1);\n      eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n      eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n      hit.vertex.add(cv.$multiply(mr1));\n    }\n  }\n  processParticle(b) {\n    let b1 = this;\n    let b2 = b;\n    let hit = Polygon.hasIntersectCircle(b1, Circle.fromCenter(b, b.radius));\n    if (hit) {\n      let cv = hit.normal.$multiply(hit.dist);\n      let t;\n      let eg = hit.edge;\n      if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n        t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n      } else {\n        t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n      }\n      let lambda = 1 / (t * t + (1 - t) * (1 - t));\n      let m0 = hit.vertex.mass || b2.mass || 1;\n      let m1 = hit.edge[0].body.mass || 1;\n      let mr0 = m0 / (m0 + m1);\n      let mr1 = m1 / (m0 + m1);\n      eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n      eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n      let c1 = b.changed.add(cv.$multiply(mr1));\n      b.previous = b.$subtract(c1);\n    }\n  }\n};\n\n// src/Play.ts\nvar Tempo = class {\n  constructor(bpm) {\n    this._listeners = {};\n    this._listenerInc = 0;\n    this.bpm = bpm;\n  }\n  static fromBeat(ms) {\n    return new Tempo(6e4 / ms);\n  }\n  get bpm() {\n    return this._bpm;\n  }\n  set bpm(n) {\n    this._bpm = n;\n    this._ms = 6e4 / this._bpm;\n  }\n  get ms() {\n    return this._ms;\n  }\n  set ms(n) {\n    this._bpm = Math.floor(6e4 / n);\n    this._ms = 6e4 / this._bpm;\n  }\n  _createID(listener) {\n    let id = \"\";\n    if (typeof listener === \"function\") {\n      id = \"_b\" + this._listenerInc++;\n    } else {\n      id = listener.name || \"_b\" + this._listenerInc++;\n    }\n    return id;\n  }\n  every(beats) {\n    let self = this;\n    let p = Array.isArray(beats) ? beats[0] : beats;\n    return {\n      start: function(fn, offset = 0, name) {\n        let id = name || self._createID(fn);\n        self._listeners[id] = { name: id, beats, period: p, index: 0, offset, duration: -1, continuous: false, fn };\n        return this;\n      },\n      progress: function(fn, offset = 0, name) {\n        let id = name || self._createID(fn);\n        self._listeners[id] = { name: id, beats, period: p, index: 0, offset, duration: -1, continuous: true, fn };\n        return this;\n      }\n    };\n  }\n  track(time) {\n    for (let k in this._listeners) {\n      if (this._listeners.hasOwnProperty(k)) {\n        let li = this._listeners[k];\n        let _t = li.offset ? time + li.offset : time;\n        let ms = li.period * this._ms;\n        let isStart = false;\n        if (_t > li.duration + ms) {\n          li.duration = _t - _t % this._ms;\n          if (Array.isArray(li.beats)) {\n            li.index = (li.index + 1) % li.beats.length;\n            li.period = li.beats[li.index];\n          }\n          isStart = true;\n        }\n        let count = Math.max(0, Math.ceil(Math.floor(li.duration / this._ms) / li.period));\n        let params = li.continuous ? [count, Num.clamp((_t - li.duration) / ms, 0, 1), _t, isStart] : [count];\n        if (li.continuous || isStart) {\n          let done = li.fn.apply(li, params);\n          if (done)\n            delete this._listeners[li.name];\n        }\n      }\n    }\n  }\n  stop(name) {\n    if (this._listeners[name])\n      delete this._listeners[name];\n  }\n  animate(time, ftime) {\n    this.track(time);\n  }\n  resize(bound, evt) {\n    return;\n  }\n  action(type, px, py, evt) {\n    return;\n  }\n};\nvar Sound = class {\n  constructor(type) {\n    this._playing = false;\n    this._type = type;\n    let _ctx = window.AudioContext || window.webkitAudioContext || false;\n    if (!_ctx)\n      throw new Error(\"Your browser doesn't support Web Audio. (No AudioContext)\");\n    this._ctx = _ctx ? new _ctx() : void 0;\n  }\n  static from(node, ctx, type = \"gen\", stream) {\n    let s = new Sound(type);\n    s._node = node;\n    s._ctx = ctx;\n    if (stream)\n      s._stream = stream;\n    return s;\n  }\n  static load(source, crossOrigin = \"anonymous\") {\n    return new Promise((resolve, reject) => {\n      let s = new Sound(\"file\");\n      s._source = typeof source === \"string\" ? new Audio(source) : source;\n      s._source.autoplay = false;\n      s._source.crossOrigin = crossOrigin;\n      s._source.addEventListener(\"ended\", function() {\n        s._playing = false;\n      });\n      s._source.addEventListener(\"error\", function() {\n        reject(\"Error loading sound\");\n      });\n      s._source.addEventListener(\"canplaythrough\", function() {\n        s._node = s._ctx.createMediaElementSource(s._source);\n        resolve(s);\n      });\n    });\n  }\n  static loadAsBuffer(url) {\n    return new Promise((resolve, reject) => {\n      let request = new XMLHttpRequest();\n      request.open(\"GET\", url, true);\n      request.responseType = \"arraybuffer\";\n      let s = new Sound(\"file\");\n      request.onload = function() {\n        s._ctx.decodeAudioData(request.response, function(buffer) {\n          s.createBuffer(buffer);\n          resolve(s);\n        }, (err) => reject(\"Error decoding audio\"));\n      };\n      request.send();\n    });\n  }\n  createBuffer(buf) {\n    this._node = this._ctx.createBufferSource();\n    if (buf !== void 0)\n      this._buffer = buf;\n    this._node.buffer = this._buffer;\n    this._node.onended = () => {\n      this._playing = false;\n    };\n    return this;\n  }\n  static generate(type, val) {\n    let s = new Sound(\"gen\");\n    return s._gen(type, val);\n  }\n  _gen(type, val) {\n    this._node = this._ctx.createOscillator();\n    let osc = this._node;\n    osc.type = type;\n    if (type === \"custom\") {\n      osc.setPeriodicWave(val);\n    } else {\n      osc.frequency.value = val;\n    }\n    return this;\n  }\n  static async input(constraint) {\n    try {\n      let s = new Sound(\"input\");\n      if (!s)\n        return void 0;\n      const c = constraint ? constraint : { audio: true, video: false };\n      s._stream = await navigator.mediaDevices.getUserMedia(c);\n      s._node = s._ctx.createMediaStreamSource(s._stream);\n      return s;\n    } catch (e) {\n      console.error(\"Cannot get audio from input device.\");\n      return Promise.resolve(null);\n    }\n  }\n  get ctx() {\n    return this._ctx;\n  }\n  get node() {\n    return this._node;\n  }\n  get outputNode() {\n    return this._outputNode;\n  }\n  get stream() {\n    return this._stream;\n  }\n  get source() {\n    return this._source;\n  }\n  get buffer() {\n    return this._buffer;\n  }\n  set buffer(b) {\n    this._buffer = b;\n  }\n  get type() {\n    return this._type;\n  }\n  get playing() {\n    return this._playing;\n  }\n  get progress() {\n    let dur = 0;\n    let curr = 0;\n    if (!!this._buffer) {\n      dur = this._buffer.duration;\n      curr = this._timestamp ? this._ctx.currentTime - this._timestamp : 0;\n    } else {\n      dur = this._source.duration;\n      curr = this._source.currentTime;\n    }\n    return curr / dur;\n  }\n  get playable() {\n    return this._type === \"input\" ? this._node !== void 0 : !!this._buffer || this._source.readyState === 4;\n  }\n  get binSize() {\n    return this.analyzer.size;\n  }\n  get sampleRate() {\n    return this._ctx.sampleRate;\n  }\n  get frequency() {\n    return this._type === \"gen\" ? this._node.frequency.value : 0;\n  }\n  set frequency(f) {\n    if (this._type === \"gen\")\n      this._node.frequency.value = f;\n  }\n  connect(node) {\n    this._node.connect(node);\n    return this;\n  }\n  setOutputNode(outputNode) {\n    this._outputNode = outputNode;\n    return this;\n  }\n  removeOutputNode() {\n    this._outputNode = null;\n    return this;\n  }\n  analyze(size = 256, minDb = -100, maxDb = -30, smooth = 0.8) {\n    let a = this._ctx.createAnalyser();\n    a.fftSize = size * 2;\n    a.minDecibels = minDb;\n    a.maxDecibels = maxDb;\n    a.smoothingTimeConstant = smooth;\n    this.analyzer = {\n      node: a,\n      size: a.frequencyBinCount,\n      data: new Uint8Array(a.frequencyBinCount)\n    };\n    this._node.connect(this.analyzer.node);\n    return this;\n  }\n  _domain(time) {\n    if (this.analyzer) {\n      if (time) {\n        this.analyzer.node.getByteTimeDomainData(this.analyzer.data);\n      } else {\n        this.analyzer.node.getByteFrequencyData(this.analyzer.data);\n      }\n      return this.analyzer.data;\n    }\n    return new Uint8Array(0);\n  }\n  _domainTo(time, size, position = [0, 0], trim = [0, 0]) {\n    let data = time ? this.timeDomain() : this.freqDomain();\n    let g = new Group();\n    for (let i = trim[0], len = data.length - trim[1]; i < len; i++) {\n      g.push(new Pt(position[0] + size[0] * i / len, position[1] + size[1] * data[i] / 255));\n    }\n    return g;\n  }\n  timeDomain() {\n    return this._domain(true);\n  }\n  timeDomainTo(size, position = [0, 0], trim = [0, 0]) {\n    return this._domainTo(true, size, position, trim);\n  }\n  freqDomain() {\n    return this._domain(false);\n  }\n  freqDomainTo(size, position = [0, 0], trim = [0, 0]) {\n    return this._domainTo(false, size, position, trim);\n  }\n  reset() {\n    this.stop();\n    this._node.disconnect();\n    return this;\n  }\n  start(timeAt = 0) {\n    if (this._ctx.state === \"suspended\")\n      this._ctx.resume();\n    if (this._type === \"file\") {\n      if (!!this._buffer) {\n        this._node.start(timeAt);\n        this._timestamp = this._ctx.currentTime + timeAt;\n      } else {\n        this._source.play();\n        if (timeAt > 0)\n          this._source.currentTime = timeAt;\n      }\n    } else if (this._type === \"gen\") {\n      this._gen(this._node.type, this._node.frequency.value);\n      this._node.start();\n      if (this.analyzer)\n        this._node.connect(this.analyzer.node);\n    }\n    (this._outputNode || this._node).connect(this._ctx.destination);\n    this._playing = true;\n    return this;\n  }\n  stop() {\n    if (this._playing)\n      (this._outputNode || this._node).disconnect(this._ctx.destination);\n    if (this._type === \"file\") {\n      if (!!this._buffer) {\n        if (this.progress < 1)\n          this._node.stop();\n      } else {\n        this._source.pause();\n      }\n    } else if (this._type === \"gen\") {\n      this._node.stop();\n    } else if (this._type === \"input\") {\n      this._stream.getAudioTracks().forEach((track) => track.stop());\n    }\n    this._playing = false;\n    return this;\n  }\n  toggle() {\n    if (this._playing) {\n      this.stop();\n    } else {\n      this.start();\n    }\n    return this;\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*! Pts.js is licensed under Apache License 2.0. Copyright © 2017-current William Ngan and contributors. (https://github.com/williamngan/pts) */\n\n\n//# sourceURL=webpack://Vinyl/./node_modules/pts/dist/index.js?");

/***/ }),

/***/ "./src/js/rectangle.js":
/*!*****************************!*\
  !*** ./src/js/rectangle.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"height\": () => (/* binding */ height),\n/* harmony export */   \"rectangle\": () => (/* binding */ rectangle),\n/* harmony export */   \"width\": () => (/* binding */ width)\n/* harmony export */ });\n/* harmony import */ var pts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pts */ \"./node_modules/pts/dist/index.js\");\n/* harmony import */ var pts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pts__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// Pts.quickStart(\"#pt_canvas\");\nlet space = new pts__WEBPACK_IMPORTED_MODULE_0__.CanvasSpace( \"#pt_canvas\" );\nlet form = space.getForm();\nlet width, height;\n//// Demo code starts (anonymous function wrapper is optional) ---\n\nfunction rectangle(width, height) {\n  \n  // to interpolate color\n  var t = 0;\n  \n  // hsl max value range (360,1,1,1)\n  let cu = pts__WEBPACK_IMPORTED_MODULE_0__.Color.hsl( pts__WEBPACK_IMPORTED_MODULE_0__.Color.maxValues(\"hsl\") );\n  \n  // recursively subdivide a rectangle\n  function subdivide( color, rect, depth, index, center ) {\n    if (depth > 1) return;\n    let qs = pts__WEBPACK_IMPORTED_MODULE_0__.Rectangle.quadrants( rect, center );\n    qs.map( (r) => r[1].ceil() ); // fix the floating-point stroke problem\n    \n    form.fill( color( rect.interpolate( t ) ) ).rects( qs );\n    \n    if (index < 0) {\n      for (let i=0, len=qs.length; i<len; i++) {\n        subdivide(color, qs[i], depth+1, i );\n      }\n    } else {\n      let i = pts__WEBPACK_IMPORTED_MODULE_0__.Num.boundValue( index+2, 0, 4 );\n      subdivide(color, qs[i], depth+1, index );\n    }\n  }\n  \n  \n  space.add( (time, ftime) => {\n    \n    t = pts__WEBPACK_IMPORTED_MODULE_0__.Num.cycle( time%10000/10000 );\n    \n    // get HSL color string, given a point position\n    let color = (p) => {\n        // 색상 지정 (무지개 - 도레미파솔라시도)\n        let p1 = p.$divide(space.size);\n        // console.log('p1', p1);\n        let p2 = space.pointer.$divide(space.size);\n        // console.log('p2', p2);\n        let c = cu.$multiply( pts__WEBPACK_IMPORTED_MODULE_0__.Pt.make( 4, 1 ).to( p2.x, p2.y/2 + p1.x/2, p1.y ) );\n        return pts__WEBPACK_IMPORTED_MODULE_0__.Color.HSLtoRGB( c ).toString(\"rgb\");\n    }\n    \n    form.stroke(false);\n    subdivide( color, space.innerBound, 0, -1, [width, height] );\n  });\n  \n  //// ----\n  \n  \n  space.bindMouse().bindTouch().play();\n  \n};\n\n\n\n\n\n//# sourceURL=webpack://Vinyl/./src/js/rectangle.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/rectangle.js");
/******/ 	
/******/ })()
;