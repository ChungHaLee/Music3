/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/brush.js":
/*!*************************!*\
  !*** ./src/js/brush.js ***!
  \*************************/
/***/ (() => {

eval("const dreamsButton = document.getElementById('dreams');\nconst linesCanvas = document.getElementsByClassName('lines');\n\ndreamsButton.addEventListener('play', function(){\n    linesCanvas[0].style.visibility = 'visible'\n})\n\n\n\nconst dpr = Math.min( window.devicePixelRatio, 2 );\nconst body = document.body;\nconst status = document.querySelector( '.status' );\nconst modes = [\n  { id: 'brush', t: 0 },\n  { id: 'line', t: 0 },\n  { id: 'dash', t: 4 },\n  { id: 'worm', t: 4 }\n];\n\nlet width,\n    height,\n    canvasWidth,\n    canvasHeight;\n\nconst brushDefaults = { x: 0.5, tx: 0.5, ttx: 0.5, y: 0, ty: 0.9, w: 1, tw: 1 };\nconst brushCanvas = createCanvas( 'brushes' );\nconst brushContext = brushCanvas.getContext( '2d' );\n\nlet mode = 0;\n\nlet canvases = [];\nlet brushes = [];\n\nlet scrollTop = 0;\nlet currentTop;\nlet lastTop;\nlet currentMode = modes[0];\n\nfunction reset() {\n\n  width = window.innerWidth;\n  height = window.innerHeight;\n  canvasWidth = width * dpr;\n  canvasHeight = height * dpr;\n\n  currentTop = 0;\n  lastTop = -1;\n\n  canvases.forEach( o => o.canvas.remove() );\n  canvases = [];\n\n  resizeCanvas( brushCanvas );\n  brushContext.scale( dpr, dpr );\n  brushContext.globalCompositeOperation = 'multiply';\n\n  brushes = [\n    { ...brushDefaults, color: 'coral' },\n    { ...brushDefaults, color: 'indigo' },\n    { ...brushDefaults, color: 'deepskyblue' },\n    { ...brushDefaults, color: 'antiquewhite' },\n    { ...brushDefaults, color: '#222' }\n  ];\n\n  brushes.forEach( brush => brush.points = [] );\n\n  build();\n\n}\n\nfunction update() {\n\n  scrollTop = Math.max( document.documentElement.scrollTop, 0 );\n\n  build();\n  // step();\n  if( Math.abs( scrollTop - currentTop ) >= 1 || lastTop === -1 ) {\n    step();\n    // step();\n  }\n\n  status.innerHTML = `scroll + click | mode: ${currentMode.id}`;\n\n\n  paintBrushes();\n\n  requestAnimationFrame( update );\n\n}\n\nfunction build() {\n\n  if( ( body.scrollHeight - scrollTop ) / height < 2 ) {\n    let canvasesToAdd = 6;\n    while( --canvasesToAdd ) {\n      const canvas = createCanvas( 'lines' );\n      const context = canvas.getContext( '2d' );\n      const top = canvas.offsetTop;\n\n      canvases.push({ canvas, context, top, visibility: 'visible' });\n\n      context.scale( dpr, dpr );\n\n      if( top !== 0 ) {\n        context.beginPath();\n        context.fillStyle = '#ccc';\n        context.strokeStyle = '#ccc';\n        context.lineWidth = 1;\n        context.moveTo( width - 10, 18 );\n        context.lineTo( width - 40, 18 );\n        context.stroke();\n        context.textAlign = 'right';\n        context.font = '12px Monospace';\n        context.fillText( top.toLocaleString() + 'px', width - 50, 22 );\n      }\n\n      context.translate( 0, -top );\n      context.globalCompositeOperation = 'multiply';\n\n    }\n  }\n\n}\n\nfunction step() {\n\n  lastTop = currentTop;\n  currentTop = Math.round( currentTop + ( scrollTop - currentTop ) * 0.2 );\n\n  const span = width * 0.9;\n  const left = width/2 - span/2;\n\n  const velocity = Math.min( Math.abs( currentTop - lastTop ) / 200, 0.1 );\n\n  brushes.forEach( (brush,i) => {\n    brush.tx += ( brush.ttx - brush.tx ) * velocity * 1.2;\n    brush.x += ( brush.tx - brush.x ) * velocity;\n    brush.y += ( brush.ty - brush.y ) * velocity * ( brush.w * 0.25);\n    brush.w += ( brush.tw - brush.w ) * velocity * 0.6;\n\n    brush.points.push({\n      x: left + ( brush.x * span ),\n      y: Math.round( currentTop + brush.y * height ),\n      w: 2 + brush.w * Math.min( width * 0.1, 100 )\n    });\n\n    let [p1, p2, p3] = brush.points;\n\n    if( p2 && p3 && Math.abs( p2.y - p3.y ) < currentMode.t ) {\n      brush.points.pop();\n    }\n\n    if( brush.points.length === 3 ) {\n      // paint on each canvas that our points touch\n      new Set( brush.points.map( point => {\n        return canvases.find( o => point.y >= o.top && point.y <= o.top + height );\n      } )).forEach( canvas => {\n        \n        if( currentMode.id === 'brush' ) {\n          \n          canvas.context.beginPath();\n\n          canvas.context.moveTo( p1.x - p1.w/2, p1.y );\n          canvas.context.quadraticCurveTo(\n            p2.x - p2.w/2, p2.y,\n            p3.x - p3.w/2, p3.y\n          );\n          canvas.context.lineTo( p3.x + p3.w/2, p3.y );\n          canvas.context.quadraticCurveTo(\n            p2.x + p2.w/2, p2.y,\n            p1.x + p1.w/2, p1.y\n          );\n\n          canvas.context.fillStyle = brush.color;\n          canvas.context.fill();\n\n        }\n        else if( currentMode.id === 'line' ) {\n          canvas.context.beginPath();\n\n          canvas.context.moveTo( p1.x, p1.y );\n          canvas.context.quadraticCurveTo(\n            p2.x, p2.y,\n            p3.x, p3.y\n          );\n\n          canvas.context.strokeStyle = brush.color;\n          canvas.context.lineWidth = 4;\n          canvas.context.stroke();\n        }\n        else if( currentMode.id === 'dash' ) {\n          canvas.context.beginPath();\n\n          if( p1.x < p3.x ) {\n            canvas.context.moveTo( p3.x-p3.w/2, p3.y );\n            canvas.context.lineTo( p1.x+p1.w/2, p1.y );\n          }\n          else {\n            canvas.context.moveTo( p3.x+p3.w/2, p3.y );\n            canvas.context.lineTo( p1.x-p1.w/2, p1.y );\n          }\n\n          canvas.context.strokeStyle = brush.color;\n          canvas.context.lineWidth = 2;\n          canvas.context.stroke();\n        }\n        else if( currentMode.id === 'worm' ) {\n          canvas.context.beginPath();\n\n          canvas.context.moveTo( p1.x - p1.w/2, p1.y );\n          canvas.context.quadraticCurveTo(\n            p2.x, p2.y,\n            p3.x - p3.w/2, p3.y\n          );\n          canvas.context.lineTo( p3.x + p3.w/2, p3.y );\n          canvas.context.quadraticCurveTo(\n            p2.x, p2.y,\n            p1.x + p1.w/2, p1.y\n          );\n\n          canvas.context.fillStyle = brush.color;\n          canvas.context.fill();\n        }\n\n      } );\n\n      brush.points = [p3];\n\n    }\n\n    if( Math.abs( brush.ttx - brush.tx ) < 0.05 ) {\n      brush.ttx = Math.random();\n    }\n\n    if( Math.abs( brush.tw - brush.w ) < 0.1 ) {\n      brush.tw = Math.random();\n    }\n\n    let oy = 0.2*i/brushes.length;\n    brush.ty = currentTop < lastTop ? 0.1 + oy : 0.8 + oy;\n  } );\n\n}\n\nfunction paintBrushes() {\n\n  brushCanvas.style.top = scrollTop + 'px';\n  brushContext.clearRect( 0, 0, width, height );\n\n  brushes.forEach( brush => {\n    let p = brush.points[0];\n    brushContext.beginPath();\n    brushContext.fillStyle = brush.color;\n    brushContext.arc( p.x, p.y-scrollTop, p.w*0.5, 0, 2 * Math.PI );\n    brushContext.fill();\n  } );\n\n}\n\nfunction createCanvas( className ) {\n\n  let c = document.createElement( 'canvas' );\n  c.className = className;\n  resizeCanvas( c );\n  body.appendChild( c );\n\n  return c;\n\n}\n\nfunction resizeCanvas( c ) {\n\n  c.width = canvasWidth;\n  c.height = canvasHeight;\n  c.style.width = width + 'px';\n  c.style.height = height + 'px';\n\n}\n\nwindow.onresize = () => {\n  // ios viewport changes height ever two seconds so\n  // only look at the width\n  if( window.innerWidth !== width ) {\n    reset();\n  }\n};\n\nreset();\nupdate();\n\ndocument.body.onclick = () => {\n  currentMode = modes[ (modes.indexOf(currentMode) + 1) % modes.length ];\n};\n\n\n//# sourceURL=webpack://Vinyl/./src/js/brush.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/brush.js"]();
/******/ 	
/******/ })()
;